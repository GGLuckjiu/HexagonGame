/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nlet can = document.querySelector('#can')\nlet ctx = can.getContext('2d')\nclass Hexagon { //六边形类\n    constructor(ctx, x, y, r = 10) {\n        this.points = []\n        this.perpendicular = 0\n        this.ctx = ctx\n        this.x = x\n        this.y = y\n        this.r = r\n    }\n    _getPoints() {\n        this.perpendicular = this.r * Math.sin(Math.PI / 3)\n        let angle = 0\n        for (let i = 0; i < 6; i++) { //以x轴为正方向 递增60度\n            this.points.push({\n                x: this.x + this.r * Math.cos(angle),\n                y: this.y + this.r * Math.sin(angle)\n            })\n            angle += Math.PI / 3\n        }\n    }\n    draw(begin, close, fill) { //判断是不是需要一笔画成\n        this._getPoints()\n        let points = this.points\n        if (!begin) {\n            this.ctx.beginPath()\n        }\n        this.ctx.moveTo(points[0].x, points[0].y)\n        for (let i = 1, len = points.length; i < len; i++) {\n            this.ctx.lineTo(points[i].x, points[i].y)\n        }\n        this.ctx.strokeStyle = \"blue\"\n        this.ctx.fillStyle = fill ? fill : '#fff'\n        this.ctx.fill()\n        if (!close) {\n            this.ctx.closePath()\n        }\n        this.ctx.stroke();\n        return this\n    }\n}\n\nclass Stage { //舞台类\n    constructor(width, height, r = 10) {\n        this.width = width\n        this.height = height\n        this.r = r\n        this.mistake = 0.1 //精度误差范围\n        this.cp = {}\n        this.lastDp = {}\n        this.dp = {} //正被探测的点\n        this.dCells = [] //需要被探测的点\n        this.cells = []\n        this.boundRect = {}\n    }\n    init() {\n        this.mistake = this.r * this.mistake\n        this.cp = {\n            x: this.width / 2,\n            y: this.height / 2\n        }\n        this.dp = Object.assign(this.cp, {\n            mark: [false, false, false, false, false, false]\n        }, //网格标记-用来判重构建网\n            {\n                done: false\n            })\n        //以x轴为正，逆时针排点\n        this.dCells.push(this.dp)\n        this._detectPoints()\n        return this\n    }\n    randomId() {\n        return (~~(Math.random() * (1 << 30))).toString(16)\n    }\n    _detectPoints() {\n        while (this.dCells.length > 0) {\n            this.dp = this.dCells.shift()\n            if (!this.dp.done) {\n                this.dp.mark.forEach((item, index) => {\n                    if (!item) {\n                        let subPoint = this._getSubPoint(index),\n                            dirctions = this._excludeSource(index, [false, false, false, false, false, false]);\n                        let verify = this._verifyPoint(subPoint)\n                        if (verify.isPushed) {\n                            let dCells = Array.prototype.concat.call([], this.dCells, this.cells)\n                            this.dp.mark[index] = dCells[verify.order]\n                        } else if (verify.isOut) {\n                            this.dp.mark[index] = -1\n                        } else {\n                            subPoint = Object.assign(subPoint, {\n                                mark: dirctions\n                            }, {\n                                    done: false\n                                })\n                            this.dCells.push(subPoint)\n                            this.dp.mark[index] = subPoint\n                        }\n                    }\n                })\n                this.dp.done = true\n                this.dp.id = this.randomId()\n            }\n            this.cells.push(this.dp)\n        }\n    }\n    _getSubPoint(order) {\n        let R = +(2 * this.r * Math.cos(Math.PI / 6)).toFixed(4)\n        let dp = this.dp\n        return {\n            x: +(dp.x + R * Math.cos(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4),\n            y: +(dp.y - R * Math.sin(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4)\n        }\n    }\n    _excludeSource(index, dir) { //排除来源节点\n        let map = [3, 4, 5, 0, 1, 2] //主从节点对应关系\n        dir[map[index]] = this.dp\n        return dir\n    }\n    _verifyPoint(p) { //判断点 已经在待探索数组中 已经越界\n        let dCells = Array.prototype.concat.call([], this.dCells, this.cells)\n        let isPushed = false\n        let order = -1\n        for (let i = 0, len = dCells.length; i < len; i++) {\n            if (Math.abs(dCells[i].x - p.x) <= this.mistake && Math.abs(dCells[i].y - p.y) <= this.mistake) {\n                isPushed = true\n                order = i\n                break\n            }\n        }\n        let isOut = p.x - this.r < 0 || p.x + this.r > this.width || p.y - this.r < 0 || p.y + this.r >\n            this.height\n        return {\n            isPushed: isPushed,\n            isOut: isOut,\n            order: order\n        }\n    }\n    draw() {\n        this.cells.forEach(item => {\n            new Hexagon(ctx, item.x, item.y, this.r).draw()\n            ctx.fillStyle = 'red'\n            ctx.font = \"10px\";\n            ctx.fillText(`${item.x},${parseInt(item.y)}`, item.x - this.r / 2, item.y);\n        })\n        return this\n    }\n    getBoundRect() {\n        let min = {\n            x: this.cells[0].x,\n            y: this.cells[0].y\n        },\n            max = {\n                x: this.cells[0].x,\n                y: this.cells[0].y\n            }\n        this.cells.forEach(item => {\n            if (item.x < min.x) {\n                min.x = item.x\n            }\n            if (item.y < min.y) {\n                min.y = item.y\n            }\n            if (item.x > max.x) {\n                max.x = item.x\n            }\n            if (item.y > max.y) {\n                max.y = item.y\n            }\n        })\n        this.boundRect = {\n            min: {\n                x: min.x - this.r,\n                y: min.y - this.r\n            },\n            max: {\n                x: max.x + this.r,\n                y: max.y + this.r\n            }\n        }\n        return this.boundRect\n    }\n}\n\nclass Interaction { //基础交互类\n    constructor() {\n        this.target = null\n        this.stage = null\n        this.bg = null\n        this.moving = false\n        this.oriPoint = {}\n        this.mappingPoints = [] //被拖拽的 对应到舞台上的点\n        this.fullLines = [] //满一行的点线\n        this.score = 0\n    }\n    clearAll() {\n        ctx.clearRect(0, 0, can.width, can.height)\n    }\n    saveBg(x, y, width, height) {\n        this.bg = ctx.getImageData(x, y, width, height)\n    }\n    putBg(x, y) {\n        ctx.putImageData(this.bg, x, y)\n    }\n    Scoring(lineArr) {\n\n    }\n    removeLines(point, ids) { //消除\n        let dirs = [0, 1, 2]\n        for (let item of dirs) {\n            let lineRes = this.getLine(point, item, ids)\n            if (lineRes.res) {\n                this.fullLines.push(lineRes.arr)\n            }\n        }\n    }\n    getLine(point, dirction, ids) {\n        let p0 = point.mark[dirction]\n        let p0Arr = [point]\n        while (p0 != -1) {\n            if (p0.done) {\n                return {\n                    res: false\n                }\n            }\n            if (typeof ids[p0.id] === 'number' && ids[p0.id] > 0) {\n                return {\n                    res: false\n                }\n            }\n            p0Arr.push(p0)\n            p0 = p0.mark[dirction]\n        }\n        let p3 = point.mark[dirction + 3]\n        let p3Arr = [point]\n        while (p3 != -1) {\n            if (p3.done) {\n                return {\n                    res: false\n                }\n            }\n            if (typeof ids[p3.id] === 'number' && ids[p3.id] > 0) {\n                return {\n                    res: false\n                }\n            }\n            p3Arr.push(p3)\n            p3 = p3.mark[dirction + 3]\n        }\n        let resArr = Array.prototype.concat.call([], p3Arr.reverse(), p0Arr.splice(1))\n        ids[point.id]++\n        return {\n            res: resArr.length === 1 ? false : true,\n            arr: resArr\n        }\n    }\n    locate(x, y, arr) {\n        let min = Infinity,\n            order = -1\n        arr.forEach((item, index) => {\n            let cal = Math.pow(item.x - x, 2) + Math.pow(item.y - y, 2)\n            if (min > cal) {\n                min = cal\n                order = index\n            }\n        })\n        return order\n    }\n    findPoints(e, target, stage) {\n        let negOne = false,\n            isPaint = false\n        let order = this.locate(e.clientX, e.clientY, this.stage.cells) //目标点\n        let point = this.stage.cells[order]\n        let destPoi = [point]\n        let targetPoi = target.points\n        if (!point.done) {\n            isPaint = true;\n            return {\n                negOne,\n                isPaint,\n                destPoi\n            }\n        }\n        for (let index = 0, len = targetPoi.length; index < len; index++) {\n            if (!targetPoi[index].dirctions) {\n                continue\n            }\n            let dirs = targetPoi[index].dirctions\n            let dirPoint = destPoi[index]\n            for (let ite of dirs) {\n                let p = dirPoint.mark[ite]\n                if (p === -1) {\n                    negOne = true;\n                    return {\n                        negOne,\n                        isPaint,\n                        destPoi\n                    }\n                } else if (!p.done) {\n                    isPaint = true;\n                    return {\n                        negOne,\n                        isPaint,\n                        destPoi\n                    }\n                } else {\n                    destPoi.push(p)\n                }\n            }\n        }\n        return {\n            negOne,\n            isPaint,\n            destPoi\n        }\n    }\n    canDrop(e, target, stage) {\n        let finds = this.findPoints(e, target, stage)\n        if (finds.negOne || finds.isPaint) {\n            return {\n                res: false\n            }\n        }\n        let mappingPoints = finds.destPoi\n        let bound = target.getBoundRect()\n        let sbound = stage.getBoundRect()\n        let inBound = !(bound.min.x + stage.r < sbound.min.x ||\n            bound.min.y + stage.r < sbound.min.y ||\n            bound.max.x - stage.r > sbound.max.x ||\n            bound.max.y - stage.r > sbound.max.y)\n        return {\n            res: (mappingPoints.indexOf(-1) < 0) && inBound,\n            mappingPoints: mappingPoints\n        }\n    }\n    drop(e) {\n        let canDrop = this.canDrop(e, this.target, this.stage)\n        if (!canDrop.res) {\n            this.putBg(0, 0)\n            this.target = this.target.move(this.oriPoint.x, this.oriPoint.y).draw()\n            return\n        }\n        this.putBg(0, 0)\n        this.mappingPoints = canDrop.mappingPoints\n        let ids = {}//匹配的id和对应这个点能消除的行数\n        this.mappingPoints.forEach(item => {\n            item.done = false\n            ids[item.id] = 0\n            new Hexagon(ctx, item.x, item.y, this.stage.r).draw(false, false, this.target.color)\n        })\n        this.fullLines.splice(0)\n        this.mappingPoints.forEach(item => {\n            this.removeLines(item, ids)\n        })\n        if (this.fullLines.length > 0) {\n            this.fullLines.forEach(item => {\n                item.forEach(p => {\n                    p.done = true\n                    new Hexagon(ctx, p.x, p.y, this.stage.r).draw(false, false, '#fff')\n                })\n            })\n        }\n\n        this.saveBg(0, 0, can.width, can.height)\n        // this.target.move(point.x, point.y).draw()\n\n        this.target = new Irregular(can.width - 60, can.height / 2, this.stage.r, 4)\n        this.target.init().draw()\n\n        this.oriPoint = {}\n    }\n    bindEvent(target, stage) {\n        this.target = target\n        this.stage = stage\n        let follow = () => {\n            this.clearAll()\n            this.putBg(0, 0)\n            this.target.draw()\n            let item = window.requestAnimationFrame(follow)\n            window.cancelAnimationFrame(item)\n        }\n        let move = e => {\n            e.preventDefault()\n            this.moving = true\n            this.target.move(e.clientX, e.clientY)\n            follow()\n        }\n        if (document.ontouchstart) {\n            can.addEventListener('touchstart', e => {\n                alert()\n                e.preventDefault()\n                if (ctx.isPointInPath(e.clientX, e.clientY)) {\n                    this.oriPoint = {\n                        x: this.target.cp.x,\n                        y: this.target.cp.y\n                    }\n                    can.addEventListener('touchmove', move)\n                }\n            })\n            can.addEventListener('touchend', e => {\n                e.preventDefault()\n                can.removeEventListener('mousemove', move)\n                if (this.moving) {\n                    this.drop(e)\n                    this.moving = false\n                }\n            })\n\n        } else {\n            can.addEventListener('mousedown', e => {\n                e.preventDefault()\n                if (ctx.isPointInPath(e.clientX, e.clientY)) {\n                    this.oriPoint = {\n                        x: this.target.cp.x,\n                        y: this.target.cp.y\n                    }\n                    can.addEventListener('mousemove', move)\n                }\n            })\n            can.addEventListener('mouseup', e => {\n                e.preventDefault()\n                can.removeEventListener('mousemove', move)\n                if (this.moving) {\n                    this.drop(e)\n                    this.moving = false\n                }\n            })\n        }\n    }\n}\n\nclass Irregular { //随机拼接多边形类\n    constructor(x, y, r = 10, maxLength = 3) {\n        this.cp = {\n            x,\n            y\n        }\n        this.r = r\n        this.color = ''\n        this.mistake = 0.1\n        this.boundRect = {}\n        this.dp = null\n        this.dirNum = 0\n        this.dirction = {} //随机结果判重\n        this.hexCount = Math.floor(Math.random() * maxLength) + 1\n        this.points = []\n    }\n    init() {\n        this.mistake = this.mistake * this.r\n        this.points.push(this.cp)\n        while (this.hexCount > 0) {\n            let point = this._detectPoint()\n            this.points.push(point)\n            // 记录派生关系\n            if (this.dp.dirctions) {\n                this.dp.dirctions.push(this.dirNum)\n            } else {\n                this.dp.dirctions = [this.dirNum]\n            }\n            this.hexCount--\n        }\n        this.getBoundRect()\n        console.log(this, '\\r\\n', this.points)\n        return this\n    }\n    _detectPoint() {\n        this._randomDetectPoint()\n        let point = this._getSubPoint(this.dirNum)\n        if (this._verifyPoint(point)) {\n            point = this._detectPoint.bind(this)()\n        }\n        return point\n    }\n    _randomDetectPoint() {\n        let pointNumber = Math.floor(Math.random() * (this.points.length - 1))\n        let dirction = Math.floor(Math.random() * 5)\n\n        if (!this.dirction[pointNumber]) {\n            this.dirction[pointNumber] = [false, false, false, false, false, false]\n            this.dirction[pointNumber][dirction] = true\n            this.dp = this.points[pointNumber]\n            this.dirNum = dirction\n            return\n        }\n        let trues = this.dirction[pointNumber].toString().match(/true/g).length\n        if (trues === this.dirction[pointNumber].length) {\n            this._randomDetectPoint.bind(this)()\n            return\n        }\n        while (this.dirction[pointNumber][dirction]) {\n            dirction = (dirction + 1) % 6\n        }\n        this.dp = this.points[pointNumber]\n        this.dirNum = dirction\n    }\n    _getSubPoint(order) {\n        let R = +(2 * this.r * Math.cos(Math.PI / 6)).toFixed(4)\n        let dp = this.dp\n        return {\n            x: +(dp.x + R * Math.cos(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4),\n            y: +(dp.y - R * Math.sin(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4)\n        }\n    }\n    _verifyPoint(p) { //判断点 已经在待探索数组中\n        let dCells = Array.prototype.concat.call([], this.points)\n        let isPushed = false\n        for (let item of dCells) {\n            if (Math.abs(item.x - p.x) < this.mistake && Math.abs(item.y - p.y) < this.mistake) {\n                isPushed = true\n                break\n            }\n        }\n        return isPushed\n    }\n    _randomColor() {\n        return \"#\" + (~~(Math.random() * (1 << 24))).toString(16)\n    }\n    draw() {\n        (!this.color) && (this.color = this._randomColor())\n        this.points.forEach((item, index, arr) => {\n            // let color = this._randomColor()\n            if (index === 0) {\n                new Hexagon(ctx, item.x, item.y, this.r).draw(false, false, this.color)\n            } else if (index === arr.length - 1) {\n                new Hexagon(ctx, item.x, item.y, this.r).draw(true, false, this.color)\n            } else {\n                new Hexagon(ctx, item.x, item.y, this.r).draw(true, false, this.color)\n            }\n        })\n        this.points.forEach(item => {\n            ctx.fillStyle = 'black'\n            ctx.font = \"10px\";\n            ctx.fillText(`${item.x},${parseInt(item.y)}`, item.x - this.r / 2, item.y);\n        })\n        return this\n    }\n    getBoundRect() {\n        let min = {\n            x: this.points[0].x,\n            y: this.points[0].y\n        },\n            max = {\n                x: this.points[0].x,\n                y: this.points[0].y\n            }\n        this.points.forEach(item => {\n            if (item.x < min.x) {\n                min.x = item.x\n            }\n            if (item.y < min.y) {\n                min.y = item.y\n            }\n            if (item.x > max.x) {\n                max.x = item.x\n            }\n            if (item.y > max.y) {\n                max.y = item.y\n            }\n        })\n        this.boundRect = {\n            min: {\n                x: min.x - this.r,\n                y: min.y - this.r\n            },\n            max: {\n                x: max.x + this.r,\n                y: max.y + this.r\n            }\n        }\n        return this.boundRect\n    }\n    move(x, y) {\n        let deltX = this.cp.x - x,\n            deltY = this.cp.y - y\n        this.cp = {\n            x,\n            y\n        }\n        this.points.forEach((item, index, arr) => {\n            item.x = item.x - deltX\n            item.y = item.y - deltY\n        })\n        return this\n    }\n}\n\n(() => {\n    let stage = new Stage(can.width - 100, can.height, 20)\n    stage.init().draw()\n\n    let bound = stage.getBoundRect()\n    ctx.beginPath()\n    ctx.moveTo(bound.min.x, bound.min.y)\n    ctx.lineTo(bound.max.x, bound.min.y)\n    ctx.lineTo(bound.max.x, bound.max.y)\n    ctx.lineTo(bound.min.x, bound.max.y)\n    ctx.closePath()\n    ctx.stroke()\n    console.log(stage)\n\n    let ia = new Interaction()\n    ia.saveBg(0, 0, can.width, can.height)\n\n    let ir = new Irregular(can.width - 50, can.height / 2, stage.r, 4)\n    ir.init().draw()\n    ia.bindEvent(ir, stage)\n})()//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmxldCBjYW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FuJylcbmxldCBjdHggPSBjYW4uZ2V0Q29udGV4dCgnMmQnKVxuY2xhc3MgSGV4YWdvbiB7IC8v5YWt6L655b2i57G7XG4gICAgY29uc3RydWN0b3IoY3R4LCB4LCB5LCByID0gMTApIHtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXVxuICAgICAgICB0aGlzLnBlcnBlbmRpY3VsYXIgPSAwXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4XG4gICAgICAgIHRoaXMueCA9IHhcbiAgICAgICAgdGhpcy55ID0geVxuICAgICAgICB0aGlzLnIgPSByXG4gICAgfVxuICAgIF9nZXRQb2ludHMoKSB7XG4gICAgICAgIHRoaXMucGVycGVuZGljdWxhciA9IHRoaXMuciAqIE1hdGguc2luKE1hdGguUEkgLyAzKVxuICAgICAgICBsZXQgYW5nbGUgPSAwXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7IC8v5LuleOi9tOS4uuato+aWueWQkSDpgJLlop42MOW6plxuICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogdGhpcy54ICsgdGhpcy5yICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMueSArIHRoaXMuciAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEkgLyAzXG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdyhiZWdpbiwgY2xvc2UsIGZpbGwpIHsgLy/liKTmlq3mmK/kuI3mmK/pnIDopoHkuIDnrJTnlLvmiJBcbiAgICAgICAgdGhpcy5fZ2V0UG9pbnRzKClcbiAgICAgICAgbGV0IHBvaW50cyA9IHRoaXMucG9pbnRzXG4gICAgICAgIGlmICghYmVnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IFwiYmx1ZVwiXG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGZpbGwgPyBmaWxsIDogJyNmZmYnXG4gICAgICAgIHRoaXMuY3R4LmZpbGwoKVxuICAgICAgICBpZiAoIWNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbn1cblxuY2xhc3MgU3RhZ2UgeyAvL+iInuWPsOexu1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHIgPSAxMCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAgICAgdGhpcy5yID0gclxuICAgICAgICB0aGlzLm1pc3Rha2UgPSAwLjEgLy/nsr7luqbor6/lt67ojIPlm7RcbiAgICAgICAgdGhpcy5jcCA9IHt9XG4gICAgICAgIHRoaXMubGFzdERwID0ge31cbiAgICAgICAgdGhpcy5kcCA9IHt9IC8v5q2j6KKr5o6i5rWL55qE54K5XG4gICAgICAgIHRoaXMuZENlbGxzID0gW10gLy/pnIDopoHooqvmjqLmtYvnmoTngrlcbiAgICAgICAgdGhpcy5jZWxscyA9IFtdXG4gICAgICAgIHRoaXMuYm91bmRSZWN0ID0ge31cbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5taXN0YWtlID0gdGhpcy5yICogdGhpcy5taXN0YWtlXG4gICAgICAgIHRoaXMuY3AgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHAgPSBPYmplY3QuYXNzaWduKHRoaXMuY3AsIHtcbiAgICAgICAgICAgIG1hcms6IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXVxuICAgICAgICB9LCAvL+e9keagvOagh+iusC3nlKjmnaXliKTph43mnoTlu7rnvZFcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgLy/ku6V46L205Li65q2j77yM6YCG5pe26ZKI5o6S54K5XG4gICAgICAgIHRoaXMuZENlbGxzLnB1c2godGhpcy5kcClcbiAgICAgICAgdGhpcy5fZGV0ZWN0UG9pbnRzKClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgcmFuZG9tSWQoKSB7XG4gICAgICAgIHJldHVybiAofn4oTWF0aC5yYW5kb20oKSAqICgxIDw8IDMwKSkpLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgICBfZGV0ZWN0UG9pbnRzKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5kQ2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kcCA9IHRoaXMuZENlbGxzLnNoaWZ0KClcbiAgICAgICAgICAgIGlmICghdGhpcy5kcC5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcC5tYXJrLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1YlBvaW50ID0gdGhpcy5fZ2V0U3ViUG9pbnQoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmN0aW9ucyA9IHRoaXMuX2V4Y2x1ZGVTb3VyY2UoaW5kZXgsIFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmVyaWZ5ID0gdGhpcy5fdmVyaWZ5UG9pbnQoc3ViUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyaWZ5LmlzUHVzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRDZWxscyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgdGhpcy5kQ2VsbHMsIHRoaXMuY2VsbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcC5tYXJrW2luZGV4XSA9IGRDZWxsc1t2ZXJpZnkub3JkZXJdXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZlcmlmeS5pc091dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHAubWFya1tpbmRleF0gPSAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJQb2ludCA9IE9iamVjdC5hc3NpZ24oc3ViUG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyazogZGlyY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRDZWxscy5wdXNoKHN1YlBvaW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHAubWFya1tpbmRleF0gPSBzdWJQb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB0aGlzLmRwLmRvbmUgPSB0cnVlXG4gICAgICAgICAgICAgICAgdGhpcy5kcC5pZCA9IHRoaXMucmFuZG9tSWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKHRoaXMuZHApXG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFN1YlBvaW50KG9yZGVyKSB7XG4gICAgICAgIGxldCBSID0gKygyICogdGhpcy5yICogTWF0aC5jb3MoTWF0aC5QSSAvIDYpKS50b0ZpeGVkKDQpXG4gICAgICAgIGxldCBkcCA9IHRoaXMuZHBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6ICsoZHAueCArIFIgKiBNYXRoLmNvcyhNYXRoLlBJIC8gNiArIE1hdGguUEkgLyAzICogb3JkZXIpKS50b0ZpeGVkKDQpLFxuICAgICAgICAgICAgeTogKyhkcC55IC0gUiAqIE1hdGguc2luKE1hdGguUEkgLyA2ICsgTWF0aC5QSSAvIDMgKiBvcmRlcikpLnRvRml4ZWQoNClcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZXhjbHVkZVNvdXJjZShpbmRleCwgZGlyKSB7IC8v5o6S6Zmk5p2l5rqQ6IqC54K5XG4gICAgICAgIGxldCBtYXAgPSBbMywgNCwgNSwgMCwgMSwgMl0gLy/kuLvku47oioLngrnlr7nlupTlhbPns7tcbiAgICAgICAgZGlyW21hcFtpbmRleF1dID0gdGhpcy5kcFxuICAgICAgICByZXR1cm4gZGlyXG4gICAgfVxuICAgIF92ZXJpZnlQb2ludChwKSB7IC8v5Yik5pat54K5IOW3sue7j+WcqOW+heaOoue0ouaVsOe7hOS4rSDlt7Lnu4/otornlYxcbiAgICAgICAgbGV0IGRDZWxscyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgdGhpcy5kQ2VsbHMsIHRoaXMuY2VsbHMpXG4gICAgICAgIGxldCBpc1B1c2hlZCA9IGZhbHNlXG4gICAgICAgIGxldCBvcmRlciA9IC0xXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkQ2VsbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkQ2VsbHNbaV0ueCAtIHAueCkgPD0gdGhpcy5taXN0YWtlICYmIE1hdGguYWJzKGRDZWxsc1tpXS55IC0gcC55KSA8PSB0aGlzLm1pc3Rha2UpIHtcbiAgICAgICAgICAgICAgICBpc1B1c2hlZCA9IHRydWVcbiAgICAgICAgICAgICAgICBvcmRlciA9IGlcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpc091dCA9IHAueCAtIHRoaXMuciA8IDAgfHwgcC54ICsgdGhpcy5yID4gdGhpcy53aWR0aCB8fCBwLnkgLSB0aGlzLnIgPCAwIHx8IHAueSArIHRoaXMuciA+XG4gICAgICAgICAgICB0aGlzLmhlaWdodFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNQdXNoZWQ6IGlzUHVzaGVkLFxuICAgICAgICAgICAgaXNPdXQ6IGlzT3V0LFxuICAgICAgICAgICAgb3JkZXI6IG9yZGVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhpcy5jZWxscy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbmV3IEhleGFnb24oY3R4LCBpdGVtLngsIGl0ZW0ueSwgdGhpcy5yKS5kcmF3KClcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJ1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBcIjEwcHhcIjtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChgJHtpdGVtLnh9LCR7cGFyc2VJbnQoaXRlbS55KX1gLCBpdGVtLnggLSB0aGlzLnIgLyAyLCBpdGVtLnkpO1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBnZXRCb3VuZFJlY3QoKSB7XG4gICAgICAgIGxldCBtaW4gPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmNlbGxzWzBdLngsXG4gICAgICAgICAgICB5OiB0aGlzLmNlbGxzWzBdLnlcbiAgICAgICAgfSxcbiAgICAgICAgICAgIG1heCA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmNlbGxzWzBdLngsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5jZWxsc1swXS55XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMuY2VsbHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnggPCBtaW4ueCkge1xuICAgICAgICAgICAgICAgIG1pbi54ID0gaXRlbS54XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS55IDwgbWluLnkpIHtcbiAgICAgICAgICAgICAgICBtaW4ueSA9IGl0ZW0ueVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0ueCA+IG1heC54KSB7XG4gICAgICAgICAgICAgICAgbWF4LnggPSBpdGVtLnhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnkgPiBtYXgueSkge1xuICAgICAgICAgICAgICAgIG1heC55ID0gaXRlbS55XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuYm91bmRSZWN0ID0ge1xuICAgICAgICAgICAgbWluOiB7XG4gICAgICAgICAgICAgICAgeDogbWluLnggLSB0aGlzLnIsXG4gICAgICAgICAgICAgICAgeTogbWluLnkgLSB0aGlzLnJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgICAgICB4OiBtYXgueCArIHRoaXMucixcbiAgICAgICAgICAgICAgICB5OiBtYXgueSArIHRoaXMuclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kUmVjdFxuICAgIH1cbn1cblxuY2xhc3MgSW50ZXJhY3Rpb24geyAvL+WfuuehgOS6pOS6kuexu1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGxcbiAgICAgICAgdGhpcy5zdGFnZSA9IG51bGxcbiAgICAgICAgdGhpcy5iZyA9IG51bGxcbiAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZVxuICAgICAgICB0aGlzLm9yaVBvaW50ID0ge31cbiAgICAgICAgdGhpcy5tYXBwaW5nUG9pbnRzID0gW10gLy/ooqvmi5bmi73nmoQg5a+55bqU5Yiw6Iie5Y+w5LiK55qE54K5XG4gICAgICAgIHRoaXMuZnVsbExpbmVzID0gW10gLy/mu6HkuIDooYznmoTngrnnur9cbiAgICAgICAgdGhpcy5zY29yZSA9IDBcbiAgICB9XG4gICAgY2xlYXJBbGwoKSB7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FuLndpZHRoLCBjYW4uaGVpZ2h0KVxuICAgIH1cbiAgICBzYXZlQmcoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmJnID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxuICAgIH1cbiAgICBwdXRCZyh4LCB5KSB7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEodGhpcy5iZywgeCwgeSlcbiAgICB9XG4gICAgU2NvcmluZyhsaW5lQXJyKSB7XG5cbiAgICB9XG4gICAgcmVtb3ZlTGluZXMocG9pbnQsIGlkcykgeyAvL+a2iOmZpFxuICAgICAgICBsZXQgZGlycyA9IFswLCAxLCAyXVxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lUmVzID0gdGhpcy5nZXRMaW5lKHBvaW50LCBpdGVtLCBpZHMpXG4gICAgICAgICAgICBpZiAobGluZVJlcy5yZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZ1bGxMaW5lcy5wdXNoKGxpbmVSZXMuYXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldExpbmUocG9pbnQsIGRpcmN0aW9uLCBpZHMpIHtcbiAgICAgICAgbGV0IHAwID0gcG9pbnQubWFya1tkaXJjdGlvbl1cbiAgICAgICAgbGV0IHAwQXJyID0gW3BvaW50XVxuICAgICAgICB3aGlsZSAocDAgIT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChwMC5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWRzW3AwLmlkXSA9PT0gJ251bWJlcicgJiYgaWRzW3AwLmlkXSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXM6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcDBBcnIucHVzaChwMClcbiAgICAgICAgICAgIHAwID0gcDAubWFya1tkaXJjdGlvbl1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcDMgPSBwb2ludC5tYXJrW2RpcmN0aW9uICsgM11cbiAgICAgICAgbGV0IHAzQXJyID0gW3BvaW50XVxuICAgICAgICB3aGlsZSAocDMgIT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChwMy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWRzW3AzLmlkXSA9PT0gJ251bWJlcicgJiYgaWRzW3AzLmlkXSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXM6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcDNBcnIucHVzaChwMylcbiAgICAgICAgICAgIHAzID0gcDMubWFya1tkaXJjdGlvbiArIDNdXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc0FyciA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgcDNBcnIucmV2ZXJzZSgpLCBwMEFyci5zcGxpY2UoMSkpXG4gICAgICAgIGlkc1twb2ludC5pZF0rK1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzOiByZXNBcnIubGVuZ3RoID09PSAxID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICAgICAgYXJyOiByZXNBcnJcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2NhdGUoeCwgeSwgYXJyKSB7XG4gICAgICAgIGxldCBtaW4gPSBJbmZpbml0eSxcbiAgICAgICAgICAgIG9yZGVyID0gLTFcbiAgICAgICAgYXJyLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgY2FsID0gTWF0aC5wb3coaXRlbS54IC0geCwgMikgKyBNYXRoLnBvdyhpdGVtLnkgLSB5LCAyKVxuICAgICAgICAgICAgaWYgKG1pbiA+IGNhbCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IGNhbFxuICAgICAgICAgICAgICAgIG9yZGVyID0gaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIG9yZGVyXG4gICAgfVxuICAgIGZpbmRQb2ludHMoZSwgdGFyZ2V0LCBzdGFnZSkge1xuICAgICAgICBsZXQgbmVnT25lID0gZmFsc2UsXG4gICAgICAgICAgICBpc1BhaW50ID0gZmFsc2VcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5sb2NhdGUoZS5jbGllbnRYLCBlLmNsaWVudFksIHRoaXMuc3RhZ2UuY2VsbHMpIC8v55uu5qCH54K5XG4gICAgICAgIGxldCBwb2ludCA9IHRoaXMuc3RhZ2UuY2VsbHNbb3JkZXJdXG4gICAgICAgIGxldCBkZXN0UG9pID0gW3BvaW50XVxuICAgICAgICBsZXQgdGFyZ2V0UG9pID0gdGFyZ2V0LnBvaW50c1xuICAgICAgICBpZiAoIXBvaW50LmRvbmUpIHtcbiAgICAgICAgICAgIGlzUGFpbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZWdPbmUsXG4gICAgICAgICAgICAgICAgaXNQYWludCxcbiAgICAgICAgICAgICAgICBkZXN0UG9pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW4gPSB0YXJnZXRQb2kubGVuZ3RoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRQb2lbaW5kZXhdLmRpcmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlycyA9IHRhcmdldFBvaVtpbmRleF0uZGlyY3Rpb25zXG4gICAgICAgICAgICBsZXQgZGlyUG9pbnQgPSBkZXN0UG9pW2luZGV4XVxuICAgICAgICAgICAgZm9yIChsZXQgaXRlIG9mIGRpcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IGRpclBvaW50Lm1hcmtbaXRlXVxuICAgICAgICAgICAgICAgIGlmIChwID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuZWdPbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVnT25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYWludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RQb2lcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXAuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpc1BhaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ09uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFpbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0UG9pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXN0UG9pLnB1c2gocClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5lZ09uZSxcbiAgICAgICAgICAgIGlzUGFpbnQsXG4gICAgICAgICAgICBkZXN0UG9pXG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuRHJvcChlLCB0YXJnZXQsIHN0YWdlKSB7XG4gICAgICAgIGxldCBmaW5kcyA9IHRoaXMuZmluZFBvaW50cyhlLCB0YXJnZXQsIHN0YWdlKVxuICAgICAgICBpZiAoZmluZHMubmVnT25lIHx8IGZpbmRzLmlzUGFpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtYXBwaW5nUG9pbnRzID0gZmluZHMuZGVzdFBvaVxuICAgICAgICBsZXQgYm91bmQgPSB0YXJnZXQuZ2V0Qm91bmRSZWN0KClcbiAgICAgICAgbGV0IHNib3VuZCA9IHN0YWdlLmdldEJvdW5kUmVjdCgpXG4gICAgICAgIGxldCBpbkJvdW5kID0gIShib3VuZC5taW4ueCArIHN0YWdlLnIgPCBzYm91bmQubWluLnggfHxcbiAgICAgICAgICAgIGJvdW5kLm1pbi55ICsgc3RhZ2UuciA8IHNib3VuZC5taW4ueSB8fFxuICAgICAgICAgICAgYm91bmQubWF4LnggLSBzdGFnZS5yID4gc2JvdW5kLm1heC54IHx8XG4gICAgICAgICAgICBib3VuZC5tYXgueSAtIHN0YWdlLnIgPiBzYm91bmQubWF4LnkpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXM6IChtYXBwaW5nUG9pbnRzLmluZGV4T2YoLTEpIDwgMCkgJiYgaW5Cb3VuZCxcbiAgICAgICAgICAgIG1hcHBpbmdQb2ludHM6IG1hcHBpbmdQb2ludHNcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcm9wKGUpIHtcbiAgICAgICAgbGV0IGNhbkRyb3AgPSB0aGlzLmNhbkRyb3AoZSwgdGhpcy50YXJnZXQsIHRoaXMuc3RhZ2UpXG4gICAgICAgIGlmICghY2FuRHJvcC5yZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHV0QmcoMCwgMClcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy50YXJnZXQubW92ZSh0aGlzLm9yaVBvaW50LngsIHRoaXMub3JpUG9pbnQueSkuZHJhdygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1dEJnKDAsIDApXG4gICAgICAgIHRoaXMubWFwcGluZ1BvaW50cyA9IGNhbkRyb3AubWFwcGluZ1BvaW50c1xuICAgICAgICBsZXQgaWRzID0ge30vL+WMuemFjeeahGlk5ZKM5a+55bqU6L+Z5Liq54K56IO95raI6Zmk55qE6KGM5pWwXG4gICAgICAgIHRoaXMubWFwcGluZ1BvaW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5kb25lID0gZmFsc2VcbiAgICAgICAgICAgIGlkc1tpdGVtLmlkXSA9IDBcbiAgICAgICAgICAgIG5ldyBIZXhhZ29uKGN0eCwgaXRlbS54LCBpdGVtLnksIHRoaXMuc3RhZ2UucikuZHJhdyhmYWxzZSwgZmFsc2UsIHRoaXMudGFyZ2V0LmNvbG9yKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmZ1bGxMaW5lcy5zcGxpY2UoMClcbiAgICAgICAgdGhpcy5tYXBwaW5nUG9pbnRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmVzKGl0ZW0sIGlkcylcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKHRoaXMuZnVsbExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbExpbmVzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwLmRvbmUgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIG5ldyBIZXhhZ29uKGN0eCwgcC54LCBwLnksIHRoaXMuc3RhZ2UucikuZHJhdyhmYWxzZSwgZmFsc2UsICcjZmZmJylcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2F2ZUJnKDAsIDAsIGNhbi53aWR0aCwgY2FuLmhlaWdodClcbiAgICAgICAgLy8gdGhpcy50YXJnZXQubW92ZShwb2ludC54LCBwb2ludC55KS5kcmF3KClcblxuICAgICAgICB0aGlzLnRhcmdldCA9IG5ldyBJcnJlZ3VsYXIoY2FuLndpZHRoIC0gNjAsIGNhbi5oZWlnaHQgLyAyLCB0aGlzLnN0YWdlLnIsIDQpXG4gICAgICAgIHRoaXMudGFyZ2V0LmluaXQoKS5kcmF3KClcblxuICAgICAgICB0aGlzLm9yaVBvaW50ID0ge31cbiAgICB9XG4gICAgYmluZEV2ZW50KHRhcmdldCwgc3RhZ2UpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXRcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlXG4gICAgICAgIGxldCBmb2xsb3cgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQWxsKClcbiAgICAgICAgICAgIHRoaXMucHV0QmcoMCwgMClcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmRyYXcoKVxuICAgICAgICAgICAgbGV0IGl0ZW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZvbGxvdylcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpdGVtKVxuICAgICAgICB9XG4gICAgICAgIGxldCBtb3ZlID0gZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy50YXJnZXQubW92ZShlLmNsaWVudFgsIGUuY2xpZW50WSlcbiAgICAgICAgICAgIGZvbGxvdygpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50Lm9udG91Y2hzdGFydCkge1xuICAgICAgICAgICAgY2FuLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBlID0+IHtcbiAgICAgICAgICAgICAgICBhbGVydCgpXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgaWYgKGN0eC5pc1BvaW50SW5QYXRoKGUuY2xpZW50WCwgZS5jbGllbnRZKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaVBvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy50YXJnZXQuY3AueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMudGFyZ2V0LmNwLnlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYW4uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgbW92ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgY2FuLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgY2FuLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmUpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW92aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmluZyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FuLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGlmIChjdHguaXNQb2ludEluUGF0aChlLmNsaWVudFgsIGUuY2xpZW50WSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlQb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMudGFyZ2V0LmNwLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnRhcmdldC5jcC55XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNhbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgY2FuLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmUpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW92aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmluZyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSXJyZWd1bGFyIHsgLy/pmo/mnLrmi7zmjqXlpJrovrnlvaLnsbtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCByID0gMTAsIG1heExlbmd0aCA9IDMpIHtcbiAgICAgICAgdGhpcy5jcCA9IHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yID0gclxuICAgICAgICB0aGlzLmNvbG9yID0gJydcbiAgICAgICAgdGhpcy5taXN0YWtlID0gMC4xXG4gICAgICAgIHRoaXMuYm91bmRSZWN0ID0ge31cbiAgICAgICAgdGhpcy5kcCA9IG51bGxcbiAgICAgICAgdGhpcy5kaXJOdW0gPSAwXG4gICAgICAgIHRoaXMuZGlyY3Rpb24gPSB7fSAvL+maj+acuue7k+aenOWIpOmHjVxuICAgICAgICB0aGlzLmhleENvdW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4TGVuZ3RoKSArIDFcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXVxuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLm1pc3Rha2UgPSB0aGlzLm1pc3Rha2UgKiB0aGlzLnJcbiAgICAgICAgdGhpcy5wb2ludHMucHVzaCh0aGlzLmNwKVxuICAgICAgICB3aGlsZSAodGhpcy5oZXhDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwb2ludCA9IHRoaXMuX2RldGVjdFBvaW50KClcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQpXG4gICAgICAgICAgICAvLyDorrDlvZXmtL7nlJ/lhbPns7tcbiAgICAgICAgICAgIGlmICh0aGlzLmRwLmRpcmN0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHAuZGlyY3Rpb25zLnB1c2godGhpcy5kaXJOdW0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHAuZGlyY3Rpb25zID0gW3RoaXMuZGlyTnVtXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZXhDb3VudC0tXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRCb3VuZFJlY3QoKVxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLCAnXFxyXFxuJywgdGhpcy5wb2ludHMpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIF9kZXRlY3RQb2ludCgpIHtcbiAgICAgICAgdGhpcy5fcmFuZG9tRGV0ZWN0UG9pbnQoKVxuICAgICAgICBsZXQgcG9pbnQgPSB0aGlzLl9nZXRTdWJQb2ludCh0aGlzLmRpck51bSlcbiAgICAgICAgaWYgKHRoaXMuX3ZlcmlmeVBvaW50KHBvaW50KSkge1xuICAgICAgICAgICAgcG9pbnQgPSB0aGlzLl9kZXRlY3RQb2ludC5iaW5kKHRoaXMpKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRcbiAgICB9XG4gICAgX3JhbmRvbURldGVjdFBvaW50KCkge1xuICAgICAgICBsZXQgcG9pbnROdW1iZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAodGhpcy5wb2ludHMubGVuZ3RoIC0gMSkpXG4gICAgICAgIGxldCBkaXJjdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUpXG5cbiAgICAgICAgaWYgKCF0aGlzLmRpcmN0aW9uW3BvaW50TnVtYmVyXSkge1xuICAgICAgICAgICAgdGhpcy5kaXJjdGlvbltwb2ludE51bWJlcl0gPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV1cbiAgICAgICAgICAgIHRoaXMuZGlyY3Rpb25bcG9pbnROdW1iZXJdW2RpcmN0aW9uXSA9IHRydWVcbiAgICAgICAgICAgIHRoaXMuZHAgPSB0aGlzLnBvaW50c1twb2ludE51bWJlcl1cbiAgICAgICAgICAgIHRoaXMuZGlyTnVtID0gZGlyY3Rpb25cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGxldCB0cnVlcyA9IHRoaXMuZGlyY3Rpb25bcG9pbnROdW1iZXJdLnRvU3RyaW5nKCkubWF0Y2goL3RydWUvZykubGVuZ3RoXG4gICAgICAgIGlmICh0cnVlcyA9PT0gdGhpcy5kaXJjdGlvbltwb2ludE51bWJlcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9yYW5kb21EZXRlY3RQb2ludC5iaW5kKHRoaXMpKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmRpcmN0aW9uW3BvaW50TnVtYmVyXVtkaXJjdGlvbl0pIHtcbiAgICAgICAgICAgIGRpcmN0aW9uID0gKGRpcmN0aW9uICsgMSkgJSA2XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcCA9IHRoaXMucG9pbnRzW3BvaW50TnVtYmVyXVxuICAgICAgICB0aGlzLmRpck51bSA9IGRpcmN0aW9uXG4gICAgfVxuICAgIF9nZXRTdWJQb2ludChvcmRlcikge1xuICAgICAgICBsZXQgUiA9ICsoMiAqIHRoaXMuciAqIE1hdGguY29zKE1hdGguUEkgLyA2KSkudG9GaXhlZCg0KVxuICAgICAgICBsZXQgZHAgPSB0aGlzLmRwXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiArKGRwLnggKyBSICogTWF0aC5jb3MoTWF0aC5QSSAvIDYgKyBNYXRoLlBJIC8gMyAqIG9yZGVyKSkudG9GaXhlZCg0KSxcbiAgICAgICAgICAgIHk6ICsoZHAueSAtIFIgKiBNYXRoLnNpbihNYXRoLlBJIC8gNiArIE1hdGguUEkgLyAzICogb3JkZXIpKS50b0ZpeGVkKDQpXG4gICAgICAgIH1cbiAgICB9XG4gICAgX3ZlcmlmeVBvaW50KHApIHsgLy/liKTmlq3ngrkg5bey57uP5Zyo5b6F5o6i57Si5pWw57uE5LitXG4gICAgICAgIGxldCBkQ2VsbHMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIHRoaXMucG9pbnRzKVxuICAgICAgICBsZXQgaXNQdXNoZWQgPSBmYWxzZVxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGRDZWxscykge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGl0ZW0ueCAtIHAueCkgPCB0aGlzLm1pc3Rha2UgJiYgTWF0aC5hYnMoaXRlbS55IC0gcC55KSA8IHRoaXMubWlzdGFrZSkge1xuICAgICAgICAgICAgICAgIGlzUHVzaGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzUHVzaGVkXG4gICAgfVxuICAgIF9yYW5kb21Db2xvcigpIHtcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgKH5+KE1hdGgucmFuZG9tKCkgKiAoMSA8PCAyNCkpKS50b1N0cmluZygxNilcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgKCF0aGlzLmNvbG9yKSAmJiAodGhpcy5jb2xvciA9IHRoaXMuX3JhbmRvbUNvbG9yKCkpXG4gICAgICAgIHRoaXMucG9pbnRzLmZvckVhY2goKGl0ZW0sIGluZGV4LCBhcnIpID0+IHtcbiAgICAgICAgICAgIC8vIGxldCBjb2xvciA9IHRoaXMuX3JhbmRvbUNvbG9yKClcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5ldyBIZXhhZ29uKGN0eCwgaXRlbS54LCBpdGVtLnksIHRoaXMucikuZHJhdyhmYWxzZSwgZmFsc2UsIHRoaXMuY29sb3IpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIG5ldyBIZXhhZ29uKGN0eCwgaXRlbS54LCBpdGVtLnksIHRoaXMucikuZHJhdyh0cnVlLCBmYWxzZSwgdGhpcy5jb2xvcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IEhleGFnb24oY3R4LCBpdGVtLngsIGl0ZW0ueSwgdGhpcy5yKS5kcmF3KHRydWUsIGZhbHNlLCB0aGlzLmNvbG9yKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjaydcbiAgICAgICAgICAgIGN0eC5mb250ID0gXCIxMHB4XCI7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoYCR7aXRlbS54fSwke3BhcnNlSW50KGl0ZW0ueSl9YCwgaXRlbS54IC0gdGhpcy5yIC8gMiwgaXRlbS55KTtcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgZ2V0Qm91bmRSZWN0KCkge1xuICAgICAgICBsZXQgbWluID0ge1xuICAgICAgICAgICAgeDogdGhpcy5wb2ludHNbMF0ueCxcbiAgICAgICAgICAgIHk6IHRoaXMucG9pbnRzWzBdLnlcbiAgICAgICAgfSxcbiAgICAgICAgICAgIG1heCA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLnBvaW50c1swXS54LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMucG9pbnRzWzBdLnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnggPCBtaW4ueCkge1xuICAgICAgICAgICAgICAgIG1pbi54ID0gaXRlbS54XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS55IDwgbWluLnkpIHtcbiAgICAgICAgICAgICAgICBtaW4ueSA9IGl0ZW0ueVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0ueCA+IG1heC54KSB7XG4gICAgICAgICAgICAgICAgbWF4LnggPSBpdGVtLnhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnkgPiBtYXgueSkge1xuICAgICAgICAgICAgICAgIG1heC55ID0gaXRlbS55XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuYm91bmRSZWN0ID0ge1xuICAgICAgICAgICAgbWluOiB7XG4gICAgICAgICAgICAgICAgeDogbWluLnggLSB0aGlzLnIsXG4gICAgICAgICAgICAgICAgeTogbWluLnkgLSB0aGlzLnJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgICAgICB4OiBtYXgueCArIHRoaXMucixcbiAgICAgICAgICAgICAgICB5OiBtYXgueSArIHRoaXMuclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kUmVjdFxuICAgIH1cbiAgICBtb3ZlKHgsIHkpIHtcbiAgICAgICAgbGV0IGRlbHRYID0gdGhpcy5jcC54IC0geCxcbiAgICAgICAgICAgIGRlbHRZID0gdGhpcy5jcC55IC0geVxuICAgICAgICB0aGlzLmNwID0ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKChpdGVtLCBpbmRleCwgYXJyKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnggPSBpdGVtLnggLSBkZWx0WFxuICAgICAgICAgICAgaXRlbS55ID0gaXRlbS55IC0gZGVsdFlcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG59XG5cbigoKSA9PiB7XG4gICAgbGV0IHN0YWdlID0gbmV3IFN0YWdlKGNhbi53aWR0aCAtIDEwMCwgY2FuLmhlaWdodCwgMjApXG4gICAgc3RhZ2UuaW5pdCgpLmRyYXcoKVxuXG4gICAgbGV0IGJvdW5kID0gc3RhZ2UuZ2V0Qm91bmRSZWN0KClcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHgubW92ZVRvKGJvdW5kLm1pbi54LCBib3VuZC5taW4ueSlcbiAgICBjdHgubGluZVRvKGJvdW5kLm1heC54LCBib3VuZC5taW4ueSlcbiAgICBjdHgubGluZVRvKGJvdW5kLm1heC54LCBib3VuZC5tYXgueSlcbiAgICBjdHgubGluZVRvKGJvdW5kLm1pbi54LCBib3VuZC5tYXgueSlcbiAgICBjdHguY2xvc2VQYXRoKClcbiAgICBjdHguc3Ryb2tlKClcbiAgICBjb25zb2xlLmxvZyhzdGFnZSlcblxuICAgIGxldCBpYSA9IG5ldyBJbnRlcmFjdGlvbigpXG4gICAgaWEuc2F2ZUJnKDAsIDAsIGNhbi53aWR0aCwgY2FuLmhlaWdodClcblxuICAgIGxldCBpciA9IG5ldyBJcnJlZ3VsYXIoY2FuLndpZHRoIC0gNTAsIGNhbi5oZWlnaHQgLyAyLCBzdGFnZS5yLCA0KVxuICAgIGlyLmluaXQoKS5kcmF3KClcbiAgICBpYS5iaW5kRXZlbnQoaXIsIHN0YWdlKVxufSkoKSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });