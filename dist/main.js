/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmNzcz9lZGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.css\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./index.css */ \"./src/index.css\")\nlet can = document.querySelector('#can')\nlet ctx = can.getContext('2d')\nclass Hexagon { //六边形类\n    constructor(ctx, x, y, r = 10) {\n        this.points = []\n        this.perpendicular = 0\n        this.ctx = ctx\n        this.x = x\n        this.y = y\n        this.r = r\n    }\n    _getPoints() {\n        this.perpendicular = this.r * Math.sin(Math.PI / 3)\n        let angle = 0\n        for (let i = 0; i < 6; i++) { //以x轴为正方向 递增60度\n            this.points.push({\n                x: this.x + this.r * Math.cos(angle),\n                y: this.y + this.r * Math.sin(angle)\n            })\n            angle += Math.PI / 3\n        }\n    }\n    draw(begin, close, fill) { //判断是不是需要一笔画成\n        this._getPoints()\n        let points = this.points\n        if (!begin) {\n            this.ctx.beginPath()\n        }\n        this.ctx.moveTo(points[0].x, points[0].y)\n        for (let i = 1, len = points.length; i < len; i++) {\n            this.ctx.lineTo(points[i].x, points[i].y)\n        }\n        this.ctx.strokeStyle = \"blue\"\n        this.ctx.fillStyle = fill ? fill : '#fff'\n        this.ctx.fill()\n        if (!close) {\n            this.ctx.closePath()\n        }\n        this.ctx.stroke();\n        return this\n    }\n}\n\nclass Stage { //舞台类\n    constructor(width, height, r = 10) {\n        this.width = width\n        this.height = height\n        this.r = r\n        this.mistake = 0.1 //精度误差范围\n        this.cp = {}\n        this.lastDp = {}\n        this.dp = {} //正被探测的点\n        this.dCells = [] //需要被探测的点\n        this.cells = []\n        this.boundRect = {}\n    }\n    init() {\n        this.mistake = this.r * this.mistake\n        this.cp = {\n            x: this.width / 2,\n            y: this.height / 2\n        }\n        this.dp = Object.assign(this.cp, {\n            mark: [false, false, false, false, false, false]\n        }, //网格标记-用来判重构建网\n            {\n                done: false\n            })\n        //以x轴为正，逆时针排点\n        this.dCells.push(this.dp)\n        this._detectPoints()\n        return this\n    }\n    randomId() {\n        return (~~(Math.random() * (1 << 30))).toString(16)\n    }\n    _detectPoints() {\n        while (this.dCells.length > 0) {\n            this.dp = this.dCells.shift()\n            if (!this.dp.done) {\n                this.dp.mark.forEach((item, index) => {\n                    if (!item) {\n                        let subPoint = this._getSubPoint(index),\n                            dirctions = this._excludeSource(index, [false, false, false, false, false, false]);\n                        let verify = this._verifyPoint(subPoint)\n                        if (verify.isPushed) {\n                            let dCells = Array.prototype.concat.call([], this.dCells, this.cells)\n                            this.dp.mark[index] = dCells[verify.order]\n                        } else if (verify.isOut) {\n                            this.dp.mark[index] = -1\n                        } else {\n                            subPoint = Object.assign(subPoint, {\n                                mark: dirctions\n                            }, {\n                                    done: false\n                                })\n                            this.dCells.push(subPoint)\n                            this.dp.mark[index] = subPoint\n                        }\n                    }\n                })\n                this.dp.done = true\n                this.dp.id = this.randomId()\n            }\n            this.cells.push(this.dp)\n        }\n    }\n    _getSubPoint(order) {\n        let R = +(2 * this.r * Math.cos(Math.PI / 6)).toFixed(4)\n        let dp = this.dp\n        return {\n            x: +(dp.x + R * Math.cos(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4),\n            y: +(dp.y - R * Math.sin(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4)\n        }\n    }\n    _excludeSource(index, dir) { //排除来源节点\n        let map = [3, 4, 5, 0, 1, 2] //主从节点对应关系\n        dir[map[index]] = this.dp\n        return dir\n    }\n    _verifyPoint(p) { //判断点 已经在待探索数组中 已经越界\n        let dCells = Array.prototype.concat.call([], this.dCells, this.cells)\n        let isPushed = false\n        let order = -1\n        for (let i = 0, len = dCells.length; i < len; i++) {\n            if (Math.abs(dCells[i].x - p.x) <= this.mistake && Math.abs(dCells[i].y - p.y) <= this.mistake) {\n                isPushed = true\n                order = i\n                break\n            }\n        }\n        let isOut = p.x - this.r < 0 || p.x + this.r > this.width || p.y - this.r < 0 || p.y + this.r >\n            this.height\n        return {\n            isPushed: isPushed,\n            isOut: isOut,\n            order: order\n        }\n    }\n    draw() {\n        this.cells.forEach(item => {\n            new Hexagon(ctx, item.x, item.y, this.r).draw()\n            ctx.fillStyle = 'red'\n            ctx.font = \"10px\";\n            ctx.fillText(`${item.x},${parseInt(item.y)}`, item.x - this.r / 2, item.y);\n        })\n        return this\n    }\n    getBoundRect() {\n        let min = {\n            x: this.cells[0].x,\n            y: this.cells[0].y\n        },\n            max = {\n                x: this.cells[0].x,\n                y: this.cells[0].y\n            }\n        this.cells.forEach(item => {\n            if (item.x < min.x) {\n                min.x = item.x\n            }\n            if (item.y < min.y) {\n                min.y = item.y\n            }\n            if (item.x > max.x) {\n                max.x = item.x\n            }\n            if (item.y > max.y) {\n                max.y = item.y\n            }\n        })\n        this.boundRect = {\n            min: {\n                x: min.x - this.r,\n                y: min.y - this.r\n            },\n            max: {\n                x: max.x + this.r,\n                y: max.y + this.r\n            }\n        }\n        return this.boundRect\n    }\n}\n\nclass Interaction { //基础交互类\n    constructor() {\n        this.target = null\n        this.stage = null\n        this.bg = null\n        this.moving = false\n        this.oriPoint = {}\n        this.mappingPoints = [] //被拖拽的 对应到舞台上的点\n        this.fullLines = [] //满一行的点线\n        this.score = 0\n    }\n    clearAll() {\n        ctx.clearRect(0, 0, can.width, can.height)\n    }\n    saveBg(x, y, width, height) {\n        this.bg = ctx.getImageData(x, y, width, height)\n    }\n    putBg(x, y) {\n        ctx.putImageData(this.bg, x, y)\n    }\n    scoring(type, lineArr) {//type:1,2每次放下一个+20，每次消除一行每个格子+2\n        if (type === 1) {\n            this.score += 20\n        } else {\n            this.score += 2\n        }\n        document.querySelector('#score').innerHTML = this.score\n    }\n    isOver() {\n        let cells = this.stage.cells\n        let target = this.target\n        for (let point of cells) {\n            if (!point.done) {\n                continue\n            }\n            let destPoi = [point]\n            let targetPoi = target.points\n            point://循环-判断每一个点\n            for (let index = 0, len = targetPoi.length; index < len; index++) {\n                if (!targetPoi[index].dirctions) {\n                    continue\n                }\n                let dirs = targetPoi[index].dirctions\n                let dirPoint = destPoi[index]\n                // dirs://循环-判断方向\n                for (let ite of dirs) {\n                    let p = dirPoint.mark[ite]\n                    if (p === -1 || !p.done) {\n                        destPoi.splice(1)\n                        break point;\n                    } else {\n                        destPoi.push(p)\n                    }\n                }\n                if (destPoi.length === targetPoi.length) {\n                    return false\n                }\n            }\n        }\n        return true\n    }\n    removeLines(point, ids) { //消除\n        let dirs = [0, 1, 2]\n        for (let item of dirs) {\n            let lineRes = this.getLine(point, item, ids)\n            if (lineRes.res) {\n                this.fullLines.push(lineRes.arr)\n            }\n        }\n    }\n    getLine(point, dirction, ids) {\n        let p0 = point.mark[dirction]\n        let p0Arr = [point]\n        while (p0 != -1) {\n            if (p0.done) {\n                return {\n                    res: false\n                }\n            }\n            if (typeof ids[p0.id] === 'number' && ids[p0.id] > 0) {\n                return {\n                    res: false\n                }\n            }\n            p0Arr.push(p0)\n            p0 = p0.mark[dirction]\n        }\n        let p3 = point.mark[dirction + 3]\n        let p3Arr = [point]\n        while (p3 != -1) {\n            if (p3.done) {\n                return {\n                    res: false\n                }\n            }\n            if (typeof ids[p3.id] === 'number' && ids[p3.id] > 0) {\n                return {\n                    res: false\n                }\n            }\n            p3Arr.push(p3)\n            p3 = p3.mark[dirction + 3]\n        }\n        let resArr = Array.prototype.concat.call([], p3Arr.reverse(), p0Arr.splice(1))\n        ids[point.id]++\n        return {\n            res: resArr.length === 1 ? false : true,\n            arr: resArr\n        }\n    }\n    locate(x, y, arr) {\n        let min = Infinity,\n            order = -1\n        arr.forEach((item, index) => {\n            let cal = Math.pow(item.x - x, 2) + Math.pow(item.y - y, 2)\n            if (min > cal) {\n                min = cal\n                order = index\n            }\n        })\n        return order\n    }\n    findPoints(e, target) {\n        let negOne = false,\n            isPaint = false\n        let order = this.locate(e.clientX, e.clientY, this.stage.cells) //目标点\n        let point = this.stage.cells[order]\n        let destPoi = [point]\n        let targetPoi = target.points\n        if (!point.done) {\n            isPaint = true;\n            return {\n                negOne,\n                isPaint,\n                destPoi\n            }\n        }\n        for (let index = 0, len = targetPoi.length; index < len; index++) {\n            if (!targetPoi[index].dirctions) {\n                continue\n            }\n            let dirs = targetPoi[index].dirctions\n            let dirPoint = destPoi[index]\n            for (let ite of dirs) {\n                let p = dirPoint.mark[ite]\n                if (p === -1) {\n                    negOne = true;\n                    return {\n                        negOne,\n                        isPaint,\n                        destPoi\n                    }\n                } else if (!p.done) {\n                    isPaint = true;\n                    return {\n                        negOne,\n                        isPaint,\n                        destPoi\n                    }\n                } else {\n                    destPoi.push(p)\n                }\n            }\n        }\n        return {\n            negOne,\n            isPaint,\n            destPoi\n        }\n    }\n    canDrop(e, target, stage) {\n        let finds = this.findPoints(e, target)\n        if (finds.negOne || finds.isPaint) {\n            return {\n                res: false\n            }\n        }\n        let mappingPoints = finds.destPoi\n        let bound = target.getBoundRect()\n        let sbound = stage.getBoundRect()\n        let inBound = !(bound.min.x + stage.r < sbound.min.x ||\n            bound.min.y + stage.r < sbound.min.y ||\n            bound.max.x - stage.r > sbound.max.x ||\n            bound.max.y - stage.r > sbound.max.y)\n        return {\n            res: (mappingPoints.indexOf(-1) < 0) && inBound,\n            mappingPoints: mappingPoints\n        }\n    }\n    drop(e) {\n        let canDrop = this.canDrop(e, this.target, this.stage)\n        if (!canDrop.res) {\n            this.putBg(0, 0)\n            this.target = this.target.move(this.oriPoint.x, this.oriPoint.y).draw()\n            return\n        }\n        this.scoring(1)\n        this.putBg(0, 0)\n        this.mappingPoints = canDrop.mappingPoints\n        let ids = {}//匹配的id和对应这个点能消除的行数\n        this.mappingPoints.forEach(item => {\n            item.done = false\n            ids[item.id] = 0\n            new Hexagon(ctx, item.x, item.y, this.stage.r).draw(false, false, this.target.color)\n        })\n        this.fullLines.splice(0)\n        this.mappingPoints.forEach(item => {\n            this.removeLines(item, ids)\n        })\n        if (this.fullLines.length > 0) {\n            this.fullLines.forEach(item => {\n                item.forEach(p => {\n                    this.scoring(2)\n                    p.done = true\n                    new Hexagon(ctx, p.x, p.y, this.stage.r).draw(false, false, '#fff')\n                })\n            })\n        }\n\n        this.saveBg(0, 0, can.width, can.height)\n        this.target = new Irregular(can.width - 60, can.height / 2, this.stage.r, 4)\n        this.target.init().draw()\n        if (this.isOver()) {\n            alert('游戏结束')\n        }\n        this.oriPoint = {}\n    }\n    bindEvent(target, stage) {\n        this.target = target\n        this.stage = stage\n        let follow = () => {\n            this.clearAll()\n            this.putBg(0, 0)\n            this.target.draw()\n            let item = window.requestAnimationFrame(follow)\n            window.cancelAnimationFrame(item)\n        }\n        let move = e => {\n            e.preventDefault()\n            this.moving = true\n            this.target.move(e.clientX, e.clientY)\n            follow()\n        }\n        if (document.ontouchstart) {\n            can.addEventListener('touchstart', e => {\n                alert()\n                e.preventDefault()\n                if (ctx.isPointInPath(e.clientX, e.clientY)) {\n                    this.oriPoint = {\n                        x: this.target.cp.x,\n                        y: this.target.cp.y\n                    }\n                    can.addEventListener('touchmove', move)\n                }\n            })\n            can.addEventListener('touchend', e => {\n                e.preventDefault()\n                can.removeEventListener('mousemove', move)\n                if (this.moving) {\n                    this.drop(e)\n                    this.moving = false\n                }\n            })\n\n        } else {\n            can.addEventListener('mousedown', e => {\n                e.preventDefault()\n                if (ctx.isPointInPath(e.clientX, e.clientY)) {\n                    this.oriPoint = {\n                        x: this.target.cp.x,\n                        y: this.target.cp.y\n                    }\n                    can.addEventListener('mousemove', move)\n                }\n            })\n            can.addEventListener('mouseup', e => {\n                e.preventDefault()\n                can.removeEventListener('mousemove', move)\n                if (this.moving) {\n                    this.drop(e)\n                    this.moving = false\n                }\n            })\n        }\n    }\n}\n\nclass Irregular { //随机拼接多边形类\n    constructor(x, y, r = 10, maxLength = 3) {\n        this.cp = {\n            x,\n            y\n        }\n        this.r = r\n        this.color = ''\n        this.mistake = 0.1\n        this.boundRect = {}\n        this.dp = null\n        this.dirNum = 0\n        this.dirction = {} //随机结果判重\n        this.hexCount = Math.floor(Math.random() * maxLength) + 1\n        this.points = []\n    }\n    init() {\n        this.mistake = this.mistake * this.r\n        this.points.push(this.cp)\n        while (this.hexCount > 0) {\n            let point = this._detectPoint()\n            this.points.push(point)\n            // 记录派生关系\n            if (this.dp.dirctions) {\n                this.dp.dirctions.push(this.dirNum)\n            } else {\n                this.dp.dirctions = [this.dirNum]\n            }\n            this.hexCount--\n        }\n        this.getBoundRect()\n        console.log(this, '\\r\\n', this.points)\n        return this\n    }\n    _detectPoint() {\n        this._randomDetectPoint()\n        let point = this._getSubPoint(this.dirNum)\n        if (this._verifyPoint(point)) {\n            point = this._detectPoint.bind(this)()\n        }\n        return point\n    }\n    _randomDetectPoint() {\n        let pointNumber = Math.floor(Math.random() * (this.points.length - 1))\n        let dirction = Math.floor(Math.random() * 5)\n\n        if (!this.dirction[pointNumber]) {\n            this.dirction[pointNumber] = [false, false, false, false, false, false]\n            this.dirction[pointNumber][dirction] = true\n            this.dp = this.points[pointNumber]\n            this.dirNum = dirction\n            return\n        }\n        let trues = this.dirction[pointNumber].toString().match(/true/g).length\n        if (trues === this.dirction[pointNumber].length) {\n            this._randomDetectPoint.bind(this)()\n            return\n        }\n        while (this.dirction[pointNumber][dirction]) {\n            dirction = (dirction + 1) % 6\n        }\n        this.dp = this.points[pointNumber]\n        this.dirNum = dirction\n    }\n    _getSubPoint(order) {\n        let R = +(2 * this.r * Math.cos(Math.PI / 6)).toFixed(4)\n        let dp = this.dp\n        return {\n            x: +(dp.x + R * Math.cos(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4),\n            y: +(dp.y - R * Math.sin(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4)\n        }\n    }\n    _verifyPoint(p) { //判断点 已经在待探索数组中\n        let dCells = Array.prototype.concat.call([], this.points)\n        let isPushed = false\n        for (let item of dCells) {\n            if (Math.abs(item.x - p.x) < this.mistake && Math.abs(item.y - p.y) < this.mistake) {\n                isPushed = true\n                break\n            }\n        }\n        return isPushed\n    }\n    _randomColor() {\n        return \"#\" + (~~(Math.random() * (1 << 24))).toString(16)\n    }\n    draw() {\n        (!this.color) && (this.color = this._randomColor())\n        this.points.forEach((item, index, arr) => {\n            // let color = this._randomColor()\n            if (index === 0) {\n                new Hexagon(ctx, item.x, item.y, this.r).draw(false, false, this.color)\n            } else if (index === arr.length - 1) {\n                new Hexagon(ctx, item.x, item.y, this.r).draw(true, false, this.color)\n            } else {\n                new Hexagon(ctx, item.x, item.y, this.r).draw(true, false, this.color)\n            }\n        })\n        this.points.forEach(item => {\n            ctx.fillStyle = 'black'\n            ctx.font = \"10px\";\n            ctx.fillText(`${item.x},${parseInt(item.y)}`, item.x - this.r / 2, item.y);\n        })\n        return this\n    }\n    getBoundRect() {\n        let min = {\n            x: this.points[0].x,\n            y: this.points[0].y\n        },\n            max = {\n                x: this.points[0].x,\n                y: this.points[0].y\n            }\n        this.points.forEach(item => {\n            if (item.x < min.x) {\n                min.x = item.x\n            }\n            if (item.y < min.y) {\n                min.y = item.y\n            }\n            if (item.x > max.x) {\n                max.x = item.x\n            }\n            if (item.y > max.y) {\n                max.y = item.y\n            }\n        })\n        this.boundRect = {\n            min: {\n                x: min.x - this.r,\n                y: min.y - this.r\n            },\n            max: {\n                x: max.x + this.r,\n                y: max.y + this.r\n            }\n        }\n        return this.boundRect\n    }\n    move(x, y) {\n        let deltX = this.cp.x - x,\n            deltY = this.cp.y - y\n        this.cp = {\n            x,\n            y\n        }\n        this.points.forEach((item, index, arr) => {\n            item.x = item.x - deltX\n            item.y = item.y - deltY\n        })\n        return this\n    }\n}\n\n(() => {\n    let stage = new Stage(can.width - 100, can.height, 30)\n    stage.init().draw()\n\n    let bound = stage.getBoundRect()\n    ctx.beginPath()\n    ctx.moveTo(bound.min.x, bound.min.y)\n    ctx.lineTo(bound.max.x, bound.min.y)\n    ctx.lineTo(bound.max.x, bound.max.y)\n    ctx.lineTo(bound.min.x, bound.max.y)\n    ctx.closePath()\n    ctx.stroke()\n    console.log(stage)\n\n    let ia = new Interaction()\n    ia.saveBg(0, 0, can.width, can.height)\n\n    let ir = new Irregular(can.width - 50, can.height / 2, stage.r, 4)\n    ir.init().draw()\n    ia.bindEvent(ir, stage)\n})()//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2luZGV4LmNzcycpXG5sZXQgY2FuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbicpXG5sZXQgY3R4ID0gY2FuLmdldENvbnRleHQoJzJkJylcbmNsYXNzIEhleGFnb24geyAvL+WFrei+ueW9ouexu1xuICAgIGNvbnN0cnVjdG9yKGN0eCwgeCwgeSwgciA9IDEwKSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW11cbiAgICAgICAgdGhpcy5wZXJwZW5kaWN1bGFyID0gMFxuICAgICAgICB0aGlzLmN0eCA9IGN0eFxuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIHRoaXMueSA9IHlcbiAgICAgICAgdGhpcy5yID0gclxuICAgIH1cbiAgICBfZ2V0UG9pbnRzKCkge1xuICAgICAgICB0aGlzLnBlcnBlbmRpY3VsYXIgPSB0aGlzLnIgKiBNYXRoLnNpbihNYXRoLlBJIC8gMylcbiAgICAgICAgbGV0IGFuZ2xlID0gMFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykgeyAvL+S7pXjovbTkuLrmraPmlrnlkJEg6YCS5aKeNjDluqZcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCArIHRoaXMuciAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnkgKyB0aGlzLnIgKiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJIC8gM1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcoYmVnaW4sIGNsb3NlLCBmaWxsKSB7IC8v5Yik5pat5piv5LiN5piv6ZyA6KaB5LiA56yU55S75oiQXG4gICAgICAgIHRoaXMuX2dldFBvaW50cygpXG4gICAgICAgIGxldCBwb2ludHMgPSB0aGlzLnBvaW50c1xuICAgICAgICBpZiAoIWJlZ2luKSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpXG4gICAgICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyhwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBcImJsdWVcIlxuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBmaWxsID8gZmlsbCA6ICcjZmZmJ1xuICAgICAgICB0aGlzLmN0eC5maWxsKClcbiAgICAgICAgaWYgKCFjbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG59XG5cbmNsYXNzIFN0YWdlIHsgLy/oiJ7lj7DnsbtcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCByID0gMTApIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgICAgIHRoaXMuciA9IHJcbiAgICAgICAgdGhpcy5taXN0YWtlID0gMC4xIC8v57K+5bqm6K+v5beu6IyD5Zu0XG4gICAgICAgIHRoaXMuY3AgPSB7fVxuICAgICAgICB0aGlzLmxhc3REcCA9IHt9XG4gICAgICAgIHRoaXMuZHAgPSB7fSAvL+ato+iiq+aOoua1i+eahOeCuVxuICAgICAgICB0aGlzLmRDZWxscyA9IFtdIC8v6ZyA6KaB6KKr5o6i5rWL55qE54K5XG4gICAgICAgIHRoaXMuY2VsbHMgPSBbXVxuICAgICAgICB0aGlzLmJvdW5kUmVjdCA9IHt9XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMubWlzdGFrZSA9IHRoaXMuciAqIHRoaXMubWlzdGFrZVxuICAgICAgICB0aGlzLmNwID0ge1xuICAgICAgICAgICAgeDogdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCAvIDJcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRwID0gT2JqZWN0LmFzc2lnbih0aGlzLmNwLCB7XG4gICAgICAgICAgICBtYXJrOiBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV1cbiAgICAgICAgfSwgLy/nvZHmoLzmoIforrAt55So5p2l5Yik6YeN5p6E5bu6572RXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgIC8v5LuleOi9tOS4uuato++8jOmAhuaXtumSiOaOkueCuVxuICAgICAgICB0aGlzLmRDZWxscy5wdXNoKHRoaXMuZHApXG4gICAgICAgIHRoaXMuX2RldGVjdFBvaW50cygpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIHJhbmRvbUlkKCkge1xuICAgICAgICByZXR1cm4gKH5+KE1hdGgucmFuZG9tKCkgKiAoMSA8PCAzMCkpKS50b1N0cmluZygxNilcbiAgICB9XG4gICAgX2RldGVjdFBvaW50cygpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZENlbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZHAgPSB0aGlzLmRDZWxscy5zaGlmdCgpXG4gICAgICAgICAgICBpZiAoIXRoaXMuZHAuZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHAubWFyay5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJQb2ludCA9IHRoaXMuX2dldFN1YlBvaW50KGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJjdGlvbnMgPSB0aGlzLl9leGNsdWRlU291cmNlKGluZGV4LCBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZlcmlmeSA9IHRoaXMuX3ZlcmlmeVBvaW50KHN1YlBvaW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmlmeS5pc1B1c2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkQ2VsbHMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIHRoaXMuZENlbGxzLCB0aGlzLmNlbGxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHAubWFya1tpbmRleF0gPSBkQ2VsbHNbdmVyaWZ5Lm9yZGVyXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJpZnkuaXNPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRwLm1hcmtbaW5kZXhdID0gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViUG9pbnQgPSBPYmplY3QuYXNzaWduKHN1YlBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcms6IGRpcmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kQ2VsbHMucHVzaChzdWJQb2ludClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRwLm1hcmtbaW5kZXhdID0gc3ViUG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgdGhpcy5kcC5kb25lID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMuZHAuaWQgPSB0aGlzLnJhbmRvbUlkKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaCh0aGlzLmRwKVxuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRTdWJQb2ludChvcmRlcikge1xuICAgICAgICBsZXQgUiA9ICsoMiAqIHRoaXMuciAqIE1hdGguY29zKE1hdGguUEkgLyA2KSkudG9GaXhlZCg0KVxuICAgICAgICBsZXQgZHAgPSB0aGlzLmRwXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiArKGRwLnggKyBSICogTWF0aC5jb3MoTWF0aC5QSSAvIDYgKyBNYXRoLlBJIC8gMyAqIG9yZGVyKSkudG9GaXhlZCg0KSxcbiAgICAgICAgICAgIHk6ICsoZHAueSAtIFIgKiBNYXRoLnNpbihNYXRoLlBJIC8gNiArIE1hdGguUEkgLyAzICogb3JkZXIpKS50b0ZpeGVkKDQpXG4gICAgICAgIH1cbiAgICB9XG4gICAgX2V4Y2x1ZGVTb3VyY2UoaW5kZXgsIGRpcikgeyAvL+aOkumZpOadpea6kOiKgueCuVxuICAgICAgICBsZXQgbWFwID0gWzMsIDQsIDUsIDAsIDEsIDJdIC8v5Li75LuO6IqC54K55a+55bqU5YWz57O7XG4gICAgICAgIGRpclttYXBbaW5kZXhdXSA9IHRoaXMuZHBcbiAgICAgICAgcmV0dXJuIGRpclxuICAgIH1cbiAgICBfdmVyaWZ5UG9pbnQocCkgeyAvL+WIpOaWreeCuSDlt7Lnu4/lnKjlvoXmjqLntKLmlbDnu4TkuK0g5bey57uP6LaK55WMXG4gICAgICAgIGxldCBkQ2VsbHMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIHRoaXMuZENlbGxzLCB0aGlzLmNlbGxzKVxuICAgICAgICBsZXQgaXNQdXNoZWQgPSBmYWxzZVxuICAgICAgICBsZXQgb3JkZXIgPSAtMVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZENlbGxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZENlbGxzW2ldLnggLSBwLngpIDw9IHRoaXMubWlzdGFrZSAmJiBNYXRoLmFicyhkQ2VsbHNbaV0ueSAtIHAueSkgPD0gdGhpcy5taXN0YWtlKSB7XG4gICAgICAgICAgICAgICAgaXNQdXNoZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgb3JkZXIgPSBpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNPdXQgPSBwLnggLSB0aGlzLnIgPCAwIHx8IHAueCArIHRoaXMuciA+IHRoaXMud2lkdGggfHwgcC55IC0gdGhpcy5yIDwgMCB8fCBwLnkgKyB0aGlzLnIgPlxuICAgICAgICAgICAgdGhpcy5oZWlnaHRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzUHVzaGVkOiBpc1B1c2hlZCxcbiAgICAgICAgICAgIGlzT3V0OiBpc091dCxcbiAgICAgICAgICAgIG9yZGVyOiBvcmRlclxuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIHRoaXMuY2VsbHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIG5ldyBIZXhhZ29uKGN0eCwgaXRlbS54LCBpdGVtLnksIHRoaXMucikuZHJhdygpXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCdcbiAgICAgICAgICAgIGN0eC5mb250ID0gXCIxMHB4XCI7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoYCR7aXRlbS54fSwke3BhcnNlSW50KGl0ZW0ueSl9YCwgaXRlbS54IC0gdGhpcy5yIC8gMiwgaXRlbS55KTtcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgZ2V0Qm91bmRSZWN0KCkge1xuICAgICAgICBsZXQgbWluID0ge1xuICAgICAgICAgICAgeDogdGhpcy5jZWxsc1swXS54LFxuICAgICAgICAgICAgeTogdGhpcy5jZWxsc1swXS55XG4gICAgICAgIH0sXG4gICAgICAgICAgICBtYXggPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5jZWxsc1swXS54LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuY2VsbHNbMF0ueVxuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLmNlbGxzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS54IDwgbWluLngpIHtcbiAgICAgICAgICAgICAgICBtaW4ueCA9IGl0ZW0ueFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0ueSA8IG1pbi55KSB7XG4gICAgICAgICAgICAgICAgbWluLnkgPSBpdGVtLnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnggPiBtYXgueCkge1xuICAgICAgICAgICAgICAgIG1heC54ID0gaXRlbS54XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS55ID4gbWF4LnkpIHtcbiAgICAgICAgICAgICAgICBtYXgueSA9IGl0ZW0ueVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmJvdW5kUmVjdCA9IHtcbiAgICAgICAgICAgIG1pbjoge1xuICAgICAgICAgICAgICAgIHg6IG1pbi54IC0gdGhpcy5yLFxuICAgICAgICAgICAgICAgIHk6IG1pbi55IC0gdGhpcy5yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICAgICAgeDogbWF4LnggKyB0aGlzLnIsXG4gICAgICAgICAgICAgICAgeTogbWF4LnkgKyB0aGlzLnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZFJlY3RcbiAgICB9XG59XG5cbmNsYXNzIEludGVyYWN0aW9uIHsgLy/ln7rnoYDkuqTkupLnsbtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsXG4gICAgICAgIHRoaXMuc3RhZ2UgPSBudWxsXG4gICAgICAgIHRoaXMuYmcgPSBudWxsXG4gICAgICAgIHRoaXMubW92aW5nID0gZmFsc2VcbiAgICAgICAgdGhpcy5vcmlQb2ludCA9IHt9XG4gICAgICAgIHRoaXMubWFwcGluZ1BvaW50cyA9IFtdIC8v6KKr5ouW5ou955qEIOWvueW6lOWIsOiInuWPsOS4iueahOeCuVxuICAgICAgICB0aGlzLmZ1bGxMaW5lcyA9IFtdIC8v5ruh5LiA6KGM55qE54K557q/XG4gICAgICAgIHRoaXMuc2NvcmUgPSAwXG4gICAgfVxuICAgIGNsZWFyQWxsKCkge1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbi53aWR0aCwgY2FuLmhlaWdodClcbiAgICB9XG4gICAgc2F2ZUJnKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5iZyA9IGN0eC5nZXRJbWFnZURhdGEoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB9XG4gICAgcHV0QmcoeCwgeSkge1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMuYmcsIHgsIHkpXG4gICAgfVxuICAgIHNjb3JpbmcodHlwZSwgbGluZUFycikgey8vdHlwZToxLDLmr4/mrKHmlL7kuIvkuIDkuKorMjDvvIzmr4/mrKHmtojpmaTkuIDooYzmr4/kuKrmoLzlrZArMlxuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zY29yZSArPSAyMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY29yZSArPSAyXG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Njb3JlJykuaW5uZXJIVE1MID0gdGhpcy5zY29yZVxuICAgIH1cbiAgICBpc092ZXIoKSB7XG4gICAgICAgIGxldCBjZWxscyA9IHRoaXMuc3RhZ2UuY2VsbHNcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMudGFyZ2V0XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIGNlbGxzKSB7XG4gICAgICAgICAgICBpZiAoIXBvaW50LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlc3RQb2kgPSBbcG9pbnRdXG4gICAgICAgICAgICBsZXQgdGFyZ2V0UG9pID0gdGFyZ2V0LnBvaW50c1xuICAgICAgICAgICAgcG9pbnQ6Ly/lvqrnjq8t5Yik5pat5q+P5LiA5Liq54K5XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbiA9IHRhcmdldFBvaS5sZW5ndGg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRQb2lbaW5kZXhdLmRpcmN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGlycyA9IHRhcmdldFBvaVtpbmRleF0uZGlyY3Rpb25zXG4gICAgICAgICAgICAgICAgbGV0IGRpclBvaW50ID0gZGVzdFBvaVtpbmRleF1cbiAgICAgICAgICAgICAgICAvLyBkaXJzOi8v5b6q546vLeWIpOaWreaWueWQkVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0ZSBvZiBkaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gZGlyUG9pbnQubWFya1tpdGVdXG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAtMSB8fCAhcC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0UG9pLnNwbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0UG9pLnB1c2gocClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVzdFBvaS5sZW5ndGggPT09IHRhcmdldFBvaS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJlbW92ZUxpbmVzKHBvaW50LCBpZHMpIHsgLy/mtojpmaRcbiAgICAgICAgbGV0IGRpcnMgPSBbMCwgMSwgMl1cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBkaXJzKSB7XG4gICAgICAgICAgICBsZXQgbGluZVJlcyA9IHRoaXMuZ2V0TGluZShwb2ludCwgaXRlbSwgaWRzKVxuICAgICAgICAgICAgaWYgKGxpbmVSZXMucmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsTGluZXMucHVzaChsaW5lUmVzLmFycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMaW5lKHBvaW50LCBkaXJjdGlvbiwgaWRzKSB7XG4gICAgICAgIGxldCBwMCA9IHBvaW50Lm1hcmtbZGlyY3Rpb25dXG4gICAgICAgIGxldCBwMEFyciA9IFtwb2ludF1cbiAgICAgICAgd2hpbGUgKHAwICE9IC0xKSB7XG4gICAgICAgICAgICBpZiAocDAuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlczogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkc1twMC5pZF0gPT09ICdudW1iZXInICYmIGlkc1twMC5pZF0gPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAwQXJyLnB1c2gocDApXG4gICAgICAgICAgICBwMCA9IHAwLm1hcmtbZGlyY3Rpb25dXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAzID0gcG9pbnQubWFya1tkaXJjdGlvbiArIDNdXG4gICAgICAgIGxldCBwM0FyciA9IFtwb2ludF1cbiAgICAgICAgd2hpbGUgKHAzICE9IC0xKSB7XG4gICAgICAgICAgICBpZiAocDMuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlczogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkc1twMy5pZF0gPT09ICdudW1iZXInICYmIGlkc1twMy5pZF0gPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAzQXJyLnB1c2gocDMpXG4gICAgICAgICAgICBwMyA9IHAzLm1hcmtbZGlyY3Rpb24gKyAzXVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNBcnIgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIHAzQXJyLnJldmVyc2UoKSwgcDBBcnIuc3BsaWNlKDEpKVxuICAgICAgICBpZHNbcG9pbnQuaWRdKytcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogcmVzQXJyLmxlbmd0aCA9PT0gMSA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgICAgIGFycjogcmVzQXJyXG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYXRlKHgsIHksIGFycikge1xuICAgICAgICBsZXQgbWluID0gSW5maW5pdHksXG4gICAgICAgICAgICBvcmRlciA9IC0xXG4gICAgICAgIGFyci5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNhbCA9IE1hdGgucG93KGl0ZW0ueCAtIHgsIDIpICsgTWF0aC5wb3coaXRlbS55IC0geSwgMilcbiAgICAgICAgICAgIGlmIChtaW4gPiBjYWwpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBjYWxcbiAgICAgICAgICAgICAgICBvcmRlciA9IGluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBvcmRlclxuICAgIH1cbiAgICBmaW5kUG9pbnRzKGUsIHRhcmdldCkge1xuICAgICAgICBsZXQgbmVnT25lID0gZmFsc2UsXG4gICAgICAgICAgICBpc1BhaW50ID0gZmFsc2VcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5sb2NhdGUoZS5jbGllbnRYLCBlLmNsaWVudFksIHRoaXMuc3RhZ2UuY2VsbHMpIC8v55uu5qCH54K5XG4gICAgICAgIGxldCBwb2ludCA9IHRoaXMuc3RhZ2UuY2VsbHNbb3JkZXJdXG4gICAgICAgIGxldCBkZXN0UG9pID0gW3BvaW50XVxuICAgICAgICBsZXQgdGFyZ2V0UG9pID0gdGFyZ2V0LnBvaW50c1xuICAgICAgICBpZiAoIXBvaW50LmRvbmUpIHtcbiAgICAgICAgICAgIGlzUGFpbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZWdPbmUsXG4gICAgICAgICAgICAgICAgaXNQYWludCxcbiAgICAgICAgICAgICAgICBkZXN0UG9pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW4gPSB0YXJnZXRQb2kubGVuZ3RoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRQb2lbaW5kZXhdLmRpcmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlycyA9IHRhcmdldFBvaVtpbmRleF0uZGlyY3Rpb25zXG4gICAgICAgICAgICBsZXQgZGlyUG9pbnQgPSBkZXN0UG9pW2luZGV4XVxuICAgICAgICAgICAgZm9yIChsZXQgaXRlIG9mIGRpcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IGRpclBvaW50Lm1hcmtbaXRlXVxuICAgICAgICAgICAgICAgIGlmIChwID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuZWdPbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVnT25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYWludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RQb2lcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXAuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpc1BhaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ09uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFpbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0UG9pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXN0UG9pLnB1c2gocClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5lZ09uZSxcbiAgICAgICAgICAgIGlzUGFpbnQsXG4gICAgICAgICAgICBkZXN0UG9pXG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuRHJvcChlLCB0YXJnZXQsIHN0YWdlKSB7XG4gICAgICAgIGxldCBmaW5kcyA9IHRoaXMuZmluZFBvaW50cyhlLCB0YXJnZXQpXG4gICAgICAgIGlmIChmaW5kcy5uZWdPbmUgfHwgZmluZHMuaXNQYWludCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXM6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hcHBpbmdQb2ludHMgPSBmaW5kcy5kZXN0UG9pXG4gICAgICAgIGxldCBib3VuZCA9IHRhcmdldC5nZXRCb3VuZFJlY3QoKVxuICAgICAgICBsZXQgc2JvdW5kID0gc3RhZ2UuZ2V0Qm91bmRSZWN0KClcbiAgICAgICAgbGV0IGluQm91bmQgPSAhKGJvdW5kLm1pbi54ICsgc3RhZ2UuciA8IHNib3VuZC5taW4ueCB8fFxuICAgICAgICAgICAgYm91bmQubWluLnkgKyBzdGFnZS5yIDwgc2JvdW5kLm1pbi55IHx8XG4gICAgICAgICAgICBib3VuZC5tYXgueCAtIHN0YWdlLnIgPiBzYm91bmQubWF4LnggfHxcbiAgICAgICAgICAgIGJvdW5kLm1heC55IC0gc3RhZ2UuciA+IHNib3VuZC5tYXgueSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogKG1hcHBpbmdQb2ludHMuaW5kZXhPZigtMSkgPCAwKSAmJiBpbkJvdW5kLFxuICAgICAgICAgICAgbWFwcGluZ1BvaW50czogbWFwcGluZ1BvaW50c1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyb3AoZSkge1xuICAgICAgICBsZXQgY2FuRHJvcCA9IHRoaXMuY2FuRHJvcChlLCB0aGlzLnRhcmdldCwgdGhpcy5zdGFnZSlcbiAgICAgICAgaWYgKCFjYW5Ecm9wLnJlcykge1xuICAgICAgICAgICAgdGhpcy5wdXRCZygwLCAwKVxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLnRhcmdldC5tb3ZlKHRoaXMub3JpUG9pbnQueCwgdGhpcy5vcmlQb2ludC55KS5kcmF3KClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NvcmluZygxKVxuICAgICAgICB0aGlzLnB1dEJnKDAsIDApXG4gICAgICAgIHRoaXMubWFwcGluZ1BvaW50cyA9IGNhbkRyb3AubWFwcGluZ1BvaW50c1xuICAgICAgICBsZXQgaWRzID0ge30vL+WMuemFjeeahGlk5ZKM5a+55bqU6L+Z5Liq54K56IO95raI6Zmk55qE6KGM5pWwXG4gICAgICAgIHRoaXMubWFwcGluZ1BvaW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5kb25lID0gZmFsc2VcbiAgICAgICAgICAgIGlkc1tpdGVtLmlkXSA9IDBcbiAgICAgICAgICAgIG5ldyBIZXhhZ29uKGN0eCwgaXRlbS54LCBpdGVtLnksIHRoaXMuc3RhZ2UucikuZHJhdyhmYWxzZSwgZmFsc2UsIHRoaXMudGFyZ2V0LmNvbG9yKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmZ1bGxMaW5lcy5zcGxpY2UoMClcbiAgICAgICAgdGhpcy5tYXBwaW5nUG9pbnRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmVzKGl0ZW0sIGlkcylcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKHRoaXMuZnVsbExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbExpbmVzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3JpbmcoMilcbiAgICAgICAgICAgICAgICAgICAgcC5kb25lID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBuZXcgSGV4YWdvbihjdHgsIHAueCwgcC55LCB0aGlzLnN0YWdlLnIpLmRyYXcoZmFsc2UsIGZhbHNlLCAnI2ZmZicpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNhdmVCZygwLCAwLCBjYW4ud2lkdGgsIGNhbi5oZWlnaHQpXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmV3IElycmVndWxhcihjYW4ud2lkdGggLSA2MCwgY2FuLmhlaWdodCAvIDIsIHRoaXMuc3RhZ2UuciwgNClcbiAgICAgICAgdGhpcy50YXJnZXQuaW5pdCgpLmRyYXcoKVxuICAgICAgICBpZiAodGhpcy5pc092ZXIoKSkge1xuICAgICAgICAgICAgYWxlcnQoJ+a4uOaIj+e7k+adnycpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlQb2ludCA9IHt9XG4gICAgfVxuICAgIGJpbmRFdmVudCh0YXJnZXQsIHN0YWdlKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZVxuICAgICAgICBsZXQgZm9sbG93ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGVhckFsbCgpXG4gICAgICAgICAgICB0aGlzLnB1dEJnKDAsIDApXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5kcmF3KClcbiAgICAgICAgICAgIGxldCBpdGVtID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmb2xsb3cpXG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaXRlbSlcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW92ZSA9IGUgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICB0aGlzLm1vdmluZyA9IHRydWVcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0Lm1vdmUoZS5jbGllbnRYLCBlLmNsaWVudFkpXG4gICAgICAgICAgICBmb2xsb3coKVxuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudC5vbnRvdWNoc3RhcnQpIHtcbiAgICAgICAgICAgIGNhbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZSA9PiB7XG4gICAgICAgICAgICAgICAgYWxlcnQoKVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGlmIChjdHguaXNQb2ludEluUGF0aChlLmNsaWVudFgsIGUuY2xpZW50WSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlQb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMudGFyZ2V0LmNwLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnRhcmdldC5jcC55XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNhbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGNhbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vdmluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmlzUG9pbnRJblBhdGgoZS5jbGllbnRYLCBlLmNsaWVudFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLnRhcmdldC5jcC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy50YXJnZXQuY3AueVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBjYW4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGNhbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vdmluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIElycmVndWxhciB7IC8v6ZqP5py65ou85o6l5aSa6L655b2i57G7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgciA9IDEwLCBtYXhMZW5ndGggPSAzKSB7XG4gICAgICAgIHRoaXMuY3AgPSB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuciA9IHJcbiAgICAgICAgdGhpcy5jb2xvciA9ICcnXG4gICAgICAgIHRoaXMubWlzdGFrZSA9IDAuMVxuICAgICAgICB0aGlzLmJvdW5kUmVjdCA9IHt9XG4gICAgICAgIHRoaXMuZHAgPSBudWxsXG4gICAgICAgIHRoaXMuZGlyTnVtID0gMFxuICAgICAgICB0aGlzLmRpcmN0aW9uID0ge30gLy/pmo/mnLrnu5PmnpzliKTph41cbiAgICAgICAgdGhpcy5oZXhDb3VudCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heExlbmd0aCkgKyAxXG4gICAgICAgIHRoaXMucG9pbnRzID0gW11cbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5taXN0YWtlID0gdGhpcy5taXN0YWtlICogdGhpcy5yXG4gICAgICAgIHRoaXMucG9pbnRzLnB1c2godGhpcy5jcClcbiAgICAgICAgd2hpbGUgKHRoaXMuaGV4Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgcG9pbnQgPSB0aGlzLl9kZXRlY3RQb2ludCgpXG4gICAgICAgICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KVxuICAgICAgICAgICAgLy8g6K6w5b2V5rS+55Sf5YWz57O7XG4gICAgICAgICAgICBpZiAodGhpcy5kcC5kaXJjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRwLmRpcmN0aW9ucy5wdXNoKHRoaXMuZGlyTnVtKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRwLmRpcmN0aW9ucyA9IFt0aGlzLmRpck51bV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGV4Q291bnQtLVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0Qm91bmRSZWN0KClcbiAgICAgICAgY29uc29sZS5sb2codGhpcywgJ1xcclxcbicsIHRoaXMucG9pbnRzKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBfZGV0ZWN0UG9pbnQoKSB7XG4gICAgICAgIHRoaXMuX3JhbmRvbURldGVjdFBvaW50KClcbiAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5fZ2V0U3ViUG9pbnQodGhpcy5kaXJOdW0pXG4gICAgICAgIGlmICh0aGlzLl92ZXJpZnlQb2ludChwb2ludCkpIHtcbiAgICAgICAgICAgIHBvaW50ID0gdGhpcy5fZGV0ZWN0UG9pbnQuYmluZCh0aGlzKSgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50XG4gICAgfVxuICAgIF9yYW5kb21EZXRlY3RQb2ludCgpIHtcbiAgICAgICAgbGV0IHBvaW50TnVtYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHRoaXMucG9pbnRzLmxlbmd0aCAtIDEpKVxuICAgICAgICBsZXQgZGlyY3Rpb24gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1KVxuXG4gICAgICAgIGlmICghdGhpcy5kaXJjdGlvbltwb2ludE51bWJlcl0pIHtcbiAgICAgICAgICAgIHRoaXMuZGlyY3Rpb25bcG9pbnROdW1iZXJdID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VdXG4gICAgICAgICAgICB0aGlzLmRpcmN0aW9uW3BvaW50TnVtYmVyXVtkaXJjdGlvbl0gPSB0cnVlXG4gICAgICAgICAgICB0aGlzLmRwID0gdGhpcy5wb2ludHNbcG9pbnROdW1iZXJdXG4gICAgICAgICAgICB0aGlzLmRpck51bSA9IGRpcmN0aW9uXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJ1ZXMgPSB0aGlzLmRpcmN0aW9uW3BvaW50TnVtYmVyXS50b1N0cmluZygpLm1hdGNoKC90cnVlL2cpLmxlbmd0aFxuICAgICAgICBpZiAodHJ1ZXMgPT09IHRoaXMuZGlyY3Rpb25bcG9pbnROdW1iZXJdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fcmFuZG9tRGV0ZWN0UG9pbnQuYmluZCh0aGlzKSgpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5kaXJjdGlvbltwb2ludE51bWJlcl1bZGlyY3Rpb25dKSB7XG4gICAgICAgICAgICBkaXJjdGlvbiA9IChkaXJjdGlvbiArIDEpICUgNlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHAgPSB0aGlzLnBvaW50c1twb2ludE51bWJlcl1cbiAgICAgICAgdGhpcy5kaXJOdW0gPSBkaXJjdGlvblxuICAgIH1cbiAgICBfZ2V0U3ViUG9pbnQob3JkZXIpIHtcbiAgICAgICAgbGV0IFIgPSArKDIgKiB0aGlzLnIgKiBNYXRoLmNvcyhNYXRoLlBJIC8gNikpLnRvRml4ZWQoNClcbiAgICAgICAgbGV0IGRwID0gdGhpcy5kcFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKyhkcC54ICsgUiAqIE1hdGguY29zKE1hdGguUEkgLyA2ICsgTWF0aC5QSSAvIDMgKiBvcmRlcikpLnRvRml4ZWQoNCksXG4gICAgICAgICAgICB5OiArKGRwLnkgLSBSICogTWF0aC5zaW4oTWF0aC5QSSAvIDYgKyBNYXRoLlBJIC8gMyAqIG9yZGVyKSkudG9GaXhlZCg0KVxuICAgICAgICB9XG4gICAgfVxuICAgIF92ZXJpZnlQb2ludChwKSB7IC8v5Yik5pat54K5IOW3sue7j+WcqOW+heaOoue0ouaVsOe7hOS4rVxuICAgICAgICBsZXQgZENlbGxzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5jYWxsKFtdLCB0aGlzLnBvaW50cylcbiAgICAgICAgbGV0IGlzUHVzaGVkID0gZmFsc2VcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBkQ2VsbHMpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhpdGVtLnggLSBwLngpIDwgdGhpcy5taXN0YWtlICYmIE1hdGguYWJzKGl0ZW0ueSAtIHAueSkgPCB0aGlzLm1pc3Rha2UpIHtcbiAgICAgICAgICAgICAgICBpc1B1c2hlZCA9IHRydWVcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1B1c2hlZFxuICAgIH1cbiAgICBfcmFuZG9tQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiBcIiNcIiArICh+fihNYXRoLnJhbmRvbSgpICogKDEgPDwgMjQpKSkudG9TdHJpbmcoMTYpXG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgICghdGhpcy5jb2xvcikgJiYgKHRoaXMuY29sb3IgPSB0aGlzLl9yYW5kb21Db2xvcigpKVxuICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKChpdGVtLCBpbmRleCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAvLyBsZXQgY29sb3IgPSB0aGlzLl9yYW5kb21Db2xvcigpXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXcgSGV4YWdvbihjdHgsIGl0ZW0ueCwgaXRlbS55LCB0aGlzLnIpLmRyYXcoZmFsc2UsIGZhbHNlLCB0aGlzLmNvbG9yKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBuZXcgSGV4YWdvbihjdHgsIGl0ZW0ueCwgaXRlbS55LCB0aGlzLnIpLmRyYXcodHJ1ZSwgZmFsc2UsIHRoaXMuY29sb3IpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ldyBIZXhhZ29uKGN0eCwgaXRlbS54LCBpdGVtLnksIHRoaXMucikuZHJhdyh0cnVlLCBmYWxzZSwgdGhpcy5jb2xvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnYmxhY2snXG4gICAgICAgICAgICBjdHguZm9udCA9IFwiMTBweFwiO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGAke2l0ZW0ueH0sJHtwYXJzZUludChpdGVtLnkpfWAsIGl0ZW0ueCAtIHRoaXMuciAvIDIsIGl0ZW0ueSk7XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGdldEJvdW5kUmVjdCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMucG9pbnRzWzBdLngsXG4gICAgICAgICAgICB5OiB0aGlzLnBvaW50c1swXS55XG4gICAgICAgIH0sXG4gICAgICAgICAgICBtYXggPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5wb2ludHNbMF0ueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnBvaW50c1swXS55XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMucG9pbnRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS54IDwgbWluLngpIHtcbiAgICAgICAgICAgICAgICBtaW4ueCA9IGl0ZW0ueFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0ueSA8IG1pbi55KSB7XG4gICAgICAgICAgICAgICAgbWluLnkgPSBpdGVtLnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnggPiBtYXgueCkge1xuICAgICAgICAgICAgICAgIG1heC54ID0gaXRlbS54XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS55ID4gbWF4LnkpIHtcbiAgICAgICAgICAgICAgICBtYXgueSA9IGl0ZW0ueVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmJvdW5kUmVjdCA9IHtcbiAgICAgICAgICAgIG1pbjoge1xuICAgICAgICAgICAgICAgIHg6IG1pbi54IC0gdGhpcy5yLFxuICAgICAgICAgICAgICAgIHk6IG1pbi55IC0gdGhpcy5yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICAgICAgeDogbWF4LnggKyB0aGlzLnIsXG4gICAgICAgICAgICAgICAgeTogbWF4LnkgKyB0aGlzLnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZFJlY3RcbiAgICB9XG4gICAgbW92ZSh4LCB5KSB7XG4gICAgICAgIGxldCBkZWx0WCA9IHRoaXMuY3AueCAtIHgsXG4gICAgICAgICAgICBkZWx0WSA9IHRoaXMuY3AueSAtIHlcbiAgICAgICAgdGhpcy5jcCA9IHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaCgoaXRlbSwgaW5kZXgsIGFycikgPT4ge1xuICAgICAgICAgICAgaXRlbS54ID0gaXRlbS54IC0gZGVsdFhcbiAgICAgICAgICAgIGl0ZW0ueSA9IGl0ZW0ueSAtIGRlbHRZXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxufVxuXG4oKCkgPT4ge1xuICAgIGxldCBzdGFnZSA9IG5ldyBTdGFnZShjYW4ud2lkdGggLSAxMDAsIGNhbi5oZWlnaHQsIDMwKVxuICAgIHN0YWdlLmluaXQoKS5kcmF3KClcblxuICAgIGxldCBib3VuZCA9IHN0YWdlLmdldEJvdW5kUmVjdCgpXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4Lm1vdmVUbyhib3VuZC5taW4ueCwgYm91bmQubWluLnkpXG4gICAgY3R4LmxpbmVUbyhib3VuZC5tYXgueCwgYm91bmQubWluLnkpXG4gICAgY3R4LmxpbmVUbyhib3VuZC5tYXgueCwgYm91bmQubWF4LnkpXG4gICAgY3R4LmxpbmVUbyhib3VuZC5taW4ueCwgYm91bmQubWF4LnkpXG4gICAgY3R4LmNsb3NlUGF0aCgpXG4gICAgY3R4LnN0cm9rZSgpXG4gICAgY29uc29sZS5sb2coc3RhZ2UpXG5cbiAgICBsZXQgaWEgPSBuZXcgSW50ZXJhY3Rpb24oKVxuICAgIGlhLnNhdmVCZygwLCAwLCBjYW4ud2lkdGgsIGNhbi5oZWlnaHQpXG5cbiAgICBsZXQgaXIgPSBuZXcgSXJyZWd1bGFyKGNhbi53aWR0aCAtIDUwLCBjYW4uaGVpZ2h0IC8gMiwgc3RhZ2UuciwgNClcbiAgICBpci5pbml0KCkuZHJhdygpXG4gICAgaWEuYmluZEV2ZW50KGlyLCBzdGFnZSlcbn0pKCkiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ })

/******/ });