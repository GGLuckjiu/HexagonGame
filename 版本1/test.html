<!DOCTYPE html>
<html>

<head>
	<title></title>
</head>
<link href="https://cdn.bootcss.com/meyer-reset/2.0/reset.css" rel="stylesheet">

<body>
	<canvas id="can" width="400" height="400" style="border:1px solid"></canvas>

	<script type="text/javascript">
		let can = document.querySelector('#can')
		let ctx = can.getContext('2d')
		class Hexagon {//六边形类
			constructor(ctx, x, y, r = 10) {
				this.points = []
				this.perpendicular = 0
				this.ctx = ctx
				this.x = x
				this.y = y
				this.r = r
			}
			_getPoints() {
				this.perpendicular = this.r * Math.sin(Math.PI / 3)
				let angle = 0
				for (let i = 0; i < 6; i++) {//以x轴为正方向 递增60度
					this.points.push({
						x: this.x + this.r * Math.cos(angle),
						y: this.y + this.r * Math.sin(angle)
					})
					angle += Math.PI / 3
				}
			}
			draw(begin, close, fill) {//判断是不是需要一笔画成
				this._getPoints()
				let points = this.points
				if (!begin) {
					this.ctx.beginPath()
				}
				this.ctx.moveTo(points[0].x, points[0].y)
				for (let i = 1, len = points.length; i < len; i++) {
					this.ctx.lineTo(points[i].x, points[i].y)
				}
				this.ctx.strokeStyle = "blue"
				this.ctx.fillStyle = fill ? fill : '#fff'
				this.ctx.fill()
				if (!close) {
					this.ctx.closePath()
				}
				this.ctx.stroke();
				return this
			}
		}

		class Stage {//舞台类
			constructor(width, height, r = 10) {
				this.width = width
				this.height = height
				this.r = r
				this.mistake = 0.1//精度误差范围
				this.cp = {}
				this.dp = {}//正被探测的点
				this.dCells = []//需要被探测的点
				this.cells = []
				this.innerCells = []//没有subpoint在框外边的图形中心点
				this.boundRect = {}
			}
			init() {
				this.mistake = this.r * this.mistake
				this.cp = {
					x: this.width / 2,
					y: this.height / 2
				}
				this.dp = Object.assign(this.cp,
					{ mark: [false, false, false, false, false, false] },
					{ done: false })
				//以x轴为正，逆时针排点
				this.dCells.push(this.dp)
				this._detectPoints()
				return this
			}
			_detectPoints() {
				while (this.dCells.length > 0) {
					this.dp = this.dCells.shift()
					let outest = false
					if (!this.dp.done) {
						this.dp.mark.forEach((item, index) => {
							if (!item) {
								let subPoint = this._getSubPoint(index),
									dirctions = this._excludeSource(index, [false, false, false, false, false, false]);
								let verify = this._verifyPoint(subPoint)
								if (!(verify.isPushed || verify.isOut)) {
									subPoint = Object.assign(subPoint,
										{ mark: dirctions },
										{ done: false })
									this.dCells.push(subPoint)
								}
								(!outest) && (outest = verify.isOut)
								this.dp.mark[index] = true
							}
						})
						this.dp.done = true
					}
					this.cells.push(this.dp)
					if (!outest) {
						this.innerCells.push(this.dp)
					}
				}
			}
			_getSubPoint(order) {
				let R = +(2 * this.r * Math.cos(Math.PI / 6)).toFixed(4)
				let dp = this.dp
				return {
					x: +(dp.x + R * Math.cos(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4),
					y: +(dp.y - R * Math.sin(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4)
				}
			}
			_excludeSource(index, dir) {//排除来源节点
				let map = [3, 4, 5, 0, 1, 2]//主从节点对应关系
				dir[map[index]] = true
				return dir
			}
			_verifyPoint(p) {//判断点 已经在待探索数组中 已经越界
				let dCells = Array.prototype.concat.call([], this.dCells, this.cells)
				let isPushed = false
				dCells.forEach(item => {
					if (Math.abs(item.x - p.x) <= this.mistake && Math.abs(item.y - p.y) <= this.mistake) {
						isPushed = true
					}
				})

				let isOut = p.x < 0 || p.x > this.width || p.y < 0 || p.y > this.height

				return {
					isPushed: isPushed,
					isOut: isOut
				}
			}
			draw() {
				// this.cells.forEach(item=>{
				// 	new Hexagon(ctx,item.x,item.y,this.r).draw()
				// })
				this.innerCells.forEach(item => {
					new Hexagon(ctx, item.x, item.y, this.r).draw()
				})
				return this
			}
			getBoundRect() {
				let min = {
					x: this.innerCells[0].x,
					y: this.innerCells[0].y
				},
					max = {
						x: this.innerCells[0].x,
						y: this.innerCells[0].y
					}
				this.innerCells.forEach(item => {
					if (item.x < min.x) {
						min.x = item.x
					}
					if (item.y < min.y) {
						min.y = item.y
					}
					if (item.x > max.x) {
						max.x = item.x
					}
					if (item.y > max.y) {
						max.y = item.y
					}
				})
				this.boundRect = {
					min: {
						x: min.x - this.r,
						y: min.y - this.r
					},
					max: {
						x: max.x + this.r,
						y: max.y + this.r
					}
				}
				return this.boundRect
			}
		}

		class Interaction {//基础交互类
			constructor() {
				this.target = null
				this.stage = null
				this.bg = null
				this.moving = false
				this.oriPoint = {}
			}
			clearAll() {
				ctx.clearRect(0, 0, can.width, can.height)
			}
			saveBg(x, y, width, height) {
				this.bg = ctx.getImageData(x, y, width, height)
			}
			putBg(x, y) {
				ctx.putImageData(this.bg, x, y)
			}
			locate(x, y, arr) {
				let min = Infinity, order = -1
				arr.forEach((item, index) => {
					let cal = Math.pow(item.x - x, 2) + Math.pow(item.y - y, 2)
					if (min > cal) {
						min = cal
						order = index
					}
				})
				return order
			}
			canDrop(target, stage) {
				let bound = target.getBoundRect()
				let sbound = stage.getBoundRect()
				return !(bound.min.x < sbound.min.x || bound.min.y < sbound.min.y || bound.max.x > sbound.max.x || bound.max.y > sbound.max.y)
			}
			drop(e) {
				if (!this.canDrop(this.target, this.stage)) {
					this.putBg(0, 0)
					this.target = this.target.move(this.oriPoint.x, this.oriPoint.y).draw()
					return
				}
				let order = this.locate(e.clientX, e.clientY, this.stage.innerCells)//目标点
				let point = this.stage.innerCells[order]
				this.putBg(0, 0)
				this.target.move(point.x, point.y).draw()
				this.saveBg(0, 0, can.width, can.height)

				this.target = new Irregular(can.width - 60, can.height / 2, this.stage.r, 4)
				this.target.init().draw()

				this.oriPoint = {}
			}
			bindEvent(target, stage) {
				this.target = target
				this.stage = stage
				let follow = () => {
					this.clearAll()
					this.putBg(0, 0)
					this.target.draw()
					let item = window.requestAnimationFrame(follow)
					window.cancelAnimationFrame(item)
				}
				let move = e => {
					this.moving = true
					this.target.move(e.clientX, e.clientY)
					follow()
				}
				can.addEventListener('mousedown', e => {
					if (ctx.isPointInPath(e.clientX, e.clientY)) {
						this.oriPoint = {
							x: this.target.cp.x,
							y: this.target.cp.y
						}
						can.addEventListener('mousemove', move)
					}
				})
				can.addEventListener('mouseup', e => {
					can.removeEventListener('mousemove', move)
					if (this.moving) {
						this.drop(e)
						this.moving = false
					}
				})
			}
		}

		class Irregular {//随机拼接多边形类
			constructor(x, y, r = 10, maxLength = 3) {
				this.cp = { x, y }
				this.r = r
				this.mistake = 0.1
				this.boundRect = {}
				this.dp = null
				this.dirNum = 0
				this.dirction = {}//随机结果判重
				this.hexCount = Math.floor(Math.random() * maxLength) + 1
				this.points = []
			}
			init() {
				this.mistake = this.mistake * this.r
				this.points.push(this.cp)
				while (this.hexCount > 0) {
					let point = this._detectPoint()
					this.points.push(point)
					this.hexCount--
				}
				this.getBoundRect()
				return this
			}
			_detectPoint() {
				this._randomDetectPoint()

				let point = this._getSubPoint(this.dirNum)
				if (this._verifyPoint(point)) {
					this._detectPoint.bind(this)()
				}
				return point
			}
			_randomDetectPoint() {
				let pointNumber = Math.floor(Math.random() * (this.points.length - 1))
				let dirction = Math.floor(Math.random() * 5)

				if (!this.dirction[pointNumber]) {
					this.dirction[pointNumber] = [false, false, false, false, false, false]
					this.dirction[pointNumber][dirction] = true
					this.dp = this.points[pointNumber]
					this.dirNum = dirction
					return
				}
				let trues = this.dirction[pointNumber].toString().match(/true/g).length
				if (trues === this.dirction[pointNumber].length) {
					this._randomDetectPoint.bind(this)()
					return
				}
				while (this.dirction[pointNumber][dirction]) {
					dirction = (dirction + 1) % 6
				}
				this.dp = this.points[pointNumber]
				this.dirNum = dirction
			}
			_getSubPoint(order) {
				let R = +(2 * this.r * Math.cos(Math.PI / 6)).toFixed(4)
				let dp = this.dp
				return {
					x: +(dp.x + R * Math.cos(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4),
					y: +(dp.y - R * Math.sin(Math.PI / 6 + Math.PI / 3 * order)).toFixed(4)
				}
			}
			_verifyPoint(p) {//判断点 已经在待探索数组中
				let dCells = Array.prototype.concat.call([], this.points)
				let isPushed = false
				dCells.forEach(item => {
					if (Math.abs(item.x - p.x) <= this.mistake && Math.abs(item.y - p.y) <= this.mistake) {
						isPushed = true
					}
				})
				return isPushed
			}
			draw() {
				this.points.forEach((item, index, arr) => {
					if (index === 0) {
						new Hexagon(ctx, item.x, item.y, this.r).draw(false, false, 'red')
					} else if (index === arr.length - 1) {
						new Hexagon(ctx, item.x, item.y, this.r).draw(true, false, 'red')
					} else {
						new Hexagon(ctx, item.x, item.y, this.r).draw(true, false, 'red')
					}
				})
				return this
			}
			getBoundRect() {
				let min = {
					x: this.points[0].x,
					y: this.points[0].y
				},
					max = {
						x: this.points[0].x,
						y: this.points[0].y
					}
				this.points.forEach(item => {
					if (item.x < min.x) {
						min.x = item.x
					}
					if (item.y < min.y) {
						min.y = item.y
					}
					if (item.x > max.x) {
						max.x = item.x
					}
					if (item.y > max.y) {
						max.y = item.y
					}
				})
				this.boundRect = {
					min: {
						x: min.x - this.r,
						y: min.y - this.r
					},
					max: {
						x: max.x + this.r,
						y: max.y + this.r
					}
				}
				return this.boundRect
			}
			move(x, y) {
				let deltX = this.cp.x - x,
					deltY = this.cp.y - y
				this.cp = {
					x, y
				}
				this.points.forEach((item, index, arr) => {
					arr[index] = {
						x: item.x - deltX,
						y: item.y - deltY
					}
				})
				return this
			}
		}

		(() => {
			let stage = new Stage(can.width - 100, can.height, 12)
			stage.init().draw()

			let bound = stage.getBoundRect()
			ctx.beginPath()
			ctx.moveTo(bound.min.x, bound.min.y)
			ctx.lineTo(bound.max.x, bound.min.y)
			ctx.lineTo(bound.max.x, bound.max.y)
			ctx.lineTo(bound.min.x, bound.max.y)
			ctx.closePath()
			ctx.stroke()
			console.log(stage)

			let ia = new Interaction()
			ia.saveBg(0, 0, can.width, can.height)


			let ir = new Irregular(can.width - 60, can.height / 2, stage.r, 4)
			ir.init().draw()
			ia.bindEvent(ir, stage)

		})()
	</script>
</body>

</html>